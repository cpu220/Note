# 算法的效率评估

> 对于算法，主要追求两个层面的目标

1. 找到问题解法：算法需要再规定的输入范围内，可靠地求得问题的正确解
2. 寻求最优解法：同一个问题，往往存在多个解法。

也就是说，在解决问题的前提下，我们希望找到最优的解法。衡量这个 **最优** 的标准，就是下面两个维度

1. 时间效率：算法执行所消耗的时间
2. 空间效率：算法占用内存空间的大小

简单说就是，既要快，又要省。


## 迭代与递归

在数据结构与算法中，重复执行某个人物是很常见的，其与算法的复杂度密切相关。而要重复执行某个人物，我们通常会选用两种基本的程序结构： 迭代与递归


### 迭代 iteration

迭代是一种重复执行某个人物的控制结构，程序会在满足一定的条件下重复执行某段代码，直到条件不再满足


1. For 循环
   - 函数的操作数量与循环输入的n成正比，所以时间复杂度描述就是 **线性关系**  
2. While 循环
   - 与for循环蕾西，也是一种实现迭代的方法，但由于初始化和更新条件变量的步骤，都是独立在循环结构之外的，因此比for循环更加灵活
3. 嵌套循环
   - for-for ，这种情况，函数的操作数量与n^2 成正比,没嵌套一层，就是一次 **升维**，从而将时间复杂度提高至更复杂的关系


### 递归 recursion
递归是通过函数调用自身来解决问题，他主要包含两个阶段

1. 递
   - 程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到 **终止条件**
2. 归
   - 触发 **终止条件**后， 程序从最深层的递归函数开始，逐层返回，汇聚每一层的结果。

> 递归的实现，通常需要满足以下条件

1. 终止条件： 决定什么时候由递-> 归
2. 递归调用： 对应**递**,函数调用自身，通常输入更小或更简化的参数
3. 返回结果：对应**归**，返回每一层递归函数的结果，直到最上层



### 总结

- 迭代
  - **自下而上**的解决问题，从最基础的步骤开发，然后不断重复或累加这些步骤，直到任务完成。
  
- 递归
  - **自上而下**的解决问题，将原问题分解为更小的子问题，这些子问题和原问题具有**相同**的形式。然后不断的将子问题继续拆解，直到基本情况停止（也就是问题已知）


## 调用栈

由于递归的特性，系统会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等，这就导致了以下2个问题

1. 函数上下文数据都存储在 **栈帧空间** 的内存区域中，直到函数返回后才被释放。因此，递归通常比迭代更加消耗内存空间
2. 递归调用函数会产生额外的开销。因此递归通常比循环的事件效率更低。


## 尾递归 Tail Recursion
如果函数在返回前的最后一步，才进行递归调用，则该函数可以被编译器或者解释器优化，使其在空间效率上与迭代相当。这种就叫 尾递归

- 普通递归
    - 当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层级调用的上下文

```ts

/* 递归 */
function recur(n: number): number {
    // 终止条件
    if (n === 1) return 1;
    // 递：递归调用
    const res = recur(n - 1);
    // 归：返回结果
    return n + res;
}

```

- 尾递归
  - 递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无需继续执行其他操作，因此系统无需保存上一层级的上下文

```ts
/* 尾递归 */
function tailRecur(n: number, res: number): number {
    // 终止条件
    if (n === 0) return res;
    // 尾递归调用
    return tailRecur(n - 1, res + n);
}
```

# 总结

递归往往在处理 **分治**相关的算法时，思路会更加直接，代码也更加易读。以 **斐波那契数** 为例

```ts
/* 斐波那契数列：递归 */
function fib(n: number): number {
    // 终止条件 f(1) = 0, f(2) = 1
    if (n === 1 || n === 2) return n - 1;
    // 递归调用 f(n) = f(n-1) + f(n-2)
    const res = fib(n - 1) + fib(n - 2);
    // 返回结果 f(n)
    return res;
}
```

这段代码，在函数内递归调用了两个函数，这就意味着，从一个调用产生了2个调用分支。这样不断递归下去，最终产生了一个层数为 n 的 递归树

本质上看，一递归提现了将问题分解为更小子问题的思维范式。

- 从算法角度看，搜索、排序、回溯、分治、动态规划等许多算法都可以使用这种思维方式

- 从数据结构角度来看，递归天然适合处理 链表、数、图的香瓜那问题。

||迭代|递归|
|---|---|---|
|实现方式|循环|函数调用|
|时间效率|高，没有额外开销|低，每次会产生额外开销|
|内存使用|低，通常使用固定大小的内存空间|高，积累函数调用可能使用大量的栈帧空间|
|适用问题|简单的循环任务|分治、搜索、排序、回溯、动态规划等|


- 模拟调用栈

```ts
function forLoopRecur(n:number):number{
    const stack :number[] = []
    let res :number = 0

    for(let i=1;i<=n;i+=1){
        // 通过入栈操作，模拟 **递**
        stack.push(i)
    }

    while(stack.length){
        // 通过出栈操作，模拟 **归**
        res += stack.pop()
    }

    return res
}
```
