#  什么是事件循环机制

## 浏览器 
Javascript 是单线程，且异步。 在栈内操作
其中单线程是为了让操作 DOM & 样式 & css 能够更加的准确且稳定。
eventloop 事件循环


## 进程
进程>线程>任务
一个主进程，可以包含多个进程
主要的进程有
### 1. 浏览器进程
主要负责界面显示，用户交互，子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。
### 2. 网络进程
负责加载网络资源，网络进城内部会启动多个线程来处理不同的网络人物

### 3. 渲染进程
渲染进程启动后，会开启一个渲染主线程，主线程负责执行 html，css，js代码
默认情况下，浏览器会为每个标签开启一个新的渲染进程，以保证不同的标签之间不互相影响

渲染主线程是浏览器最繁忙的线程，需要它处理的任务包括但不限于：
* 解析 HTML：语法解析
* 解析 CSS：语法解析
* 计算样式
* 布局
  * 计算 几何信息
* 处理图层
* 每秒把页面画 60次
* 执行全局js代码
* 执行事件处理函数
* 执行计时器的回调函数


----

为了能够将所有的进程、线程分优先级，进行合理的调度，浏览器内部使用了任务队列的机制

## message queue  消息队列 
// message_loop  事件循环也叫  消息循环   w3c 叫event loop
1. 在最开始的时候，渲染主线程会进入一个无限循环
2. 每一次循环会检查消息队列中是否有【任务】存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。
3. 其他所有线程，包括其他进程的线程，可以随时向消息队列添加任务，新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒，以继续循环拿人物。

## 异步
代码在执行过程中，会遇到一些无法立即处理的任务，比如：
  * 计时完成后需要执行的任务
  * 网络通讯完成后需要执行的任务
  * 用户操作后需要执行的任务
如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于【阻塞】的状态，从而导致浏览器【卡死】


> 如何理解 js 的异步
* js是一门【单线程】的语言，这是因为他运行在浏览器渲染主线程中，而主线程只有【一个】。
* 渲染主线程承担着诸多的工作，渲染画面，执行 JS都在其中运行。
* 如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。
* 这样依赖，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。

* 所以，流量器采用异步的方式来避免。
* 具体做法事当某些任务发生时，比如计时器，网络，事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码，当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。
* 在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行



---

> 任务有优先级吗？
* 任务没有优先级，但在消息队列中，是先进先出

消息队列是有优先级的

根据w3c的最新解释：
* 每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不通类型的任务可以分数不通的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。
* 浏览器必须准备好一个微队列，微队列中的任务有限所有其他任务执行。


随着浏览器的复杂度急剧提升，w3c，不再使用宏队列的说法。



在目前chrome的实现中，至少包含了下面的队列
1. 延迟队列
  * 主要存放计时器，优先级 中
2. 交互队列
  * 用于存放用户操作后产生的事件处理任务，优先级高
3. 微队列 microtask queue
  * 用户存放需要最快执行的任务，优先级最高
  * 添加微队列主要是 new Promise 和 MutationObserver

> 阐述一下 js的事件循环
* 事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。
* 在chrome的源码中，他开启一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。
* 过去把消息队列简单分为宏任务和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的事一种更加灵活多变的处理方式。
* 根据w3c官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不通的任务可以属于不同的队列。不通任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务，但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。


**单线程是异步产生的原因**
**事件循环是异步的实现方式**

---

### 宏任务 (macro task)
* script 整体代码块
* setTimeout 
* setInterval
* postMessage
* I/O
* UI交互事件
* requestAnimationFrame

### 微任务(micro task)
* new Promise
* MutationObserver


## node
node中的eventloop和浏览器中完全不相同， node用V8引擎作为js解析器，而IO上的处理用了自己设计的libuv
  libuv是一个基于事件驱动的跨平爱抽象层，封装了不同的操作系统一些底层特性，对外提供统一的api

nodejs的运行机制
* V8引擎解析js脚本
* 解析后的代码，调用node api
* libuv库负责node api的执行。将不同的任务分配给不同的现成，形成一个eventloop。以异步的方式将任务的执行结果返回给V8
* V8再将结果返回给用户
 
### 执行阶段
* 外部输入数据
* 轮询阶段 poll
* 检查阶段 check
* 关闭事件回调阶段 close callback
* 定时器检测阶段 timer
* I/O 事件 回调阶段  I/O callbacks
* 闲置阶段 idle,prepare
* 轮询阶段 （反复执行）

node的事件循环，是没执行一个re

