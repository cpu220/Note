#  什么是事件循环机制

## 浏览器 
Javascript 是单线程，且异步。代码在调用栈中执行
其中单线程是为了让操作 DOM & 样式 & css 能够更加的准确且稳定。
eventloop 事件循环


## 进程
进程>线程>任务
一个浏览器主进程，可以包含多个子进程（如渲染进程、网络进程等）
主要的进程有
### 1. 浏览器进程
主要负责界面显示，用户交互，子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。
### 2. 网络进程
负责加载网络资源，网络进程内部会启动多个线程来处理不同的网络任务

### 3. 渲染进程
渲染进程启动后，会开启一个渲染主线程，主线程负责执行 html，css，js代码
默认情况下，浏览器会为每个标签开启一个新的渲染进程，以保证不同的标签之间不互相影响

**关于网络进程的工作机制补充：**
网络进程是浏览器级别的共享资源，而不是每个标签页独立的。对于同一域名的请求，无论来自哪个标签页，都会共享浏览器的并发连接限制（通常是6个）。如果A标签页同时请求100个请求，B标签页同时请求100个请求，并且这些请求都是针对同一个域名的，那么它们会共享6个并发连接的限制，而不是各自有6个连接。

对于不同域名的请求，每个域名都会有独立的并发连接限制。例如，A标签页访问域名example.com，B标签页访问域名test.com，那么这两个域名各自都可以有6个并发连接，互不影响。浏览器对不同域名的请求采用独立的并发连接池管理。

渲染主线程是浏览器最繁忙的线程，需要它处理的任务包括但不限于：
* 解析 HTML：语法解析
* 解析 CSS：语法解析
* 计算样式
* 布局
  * 计算 几何信息
* 处理图层
* 每秒把页面画 60次
* 执行全局js代码
* 执行事件处理函数
* 执行计时器的回调函数


----

为了能够将所有的进程、线程分优先级，进行合理的调度，浏览器内部使用了任务队列的机制

## message queue  消息队列 
// message_loop  事件循环也叫  消息循环   w3c 叫event loop
1. 在最开始的时候，渲染主线程会进入一个无限循环
2. 每一次循环会检查消息队列中是否有【任务】存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。
3. 其他所有线程，包括其他进程的线程，可以随时向消息队列添加任务，新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒，以继续循环拿任务。

## 异步
代码在执行过程中，会遇到一些无法立即处理的任务，比如：
  * 计时完成后需要执行的任务
  * 网络通讯完成后需要执行的任务
  * 用户操作后需要执行的任务
如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于【阻塞】的状态，从而导致浏览器【卡死】


> 如何理解 js 的异步
* js是一门【单线程】的语言，这是因为他运行在浏览器渲染主线程中，而主线程只有【一个】。
* 渲染主线程承担着诸多的工作，渲染画面，执行 JS都在其中运行。
* 如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。
* 这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。

* 所以，浏览器采用异步的方式来避免。
* 具体做法是当某些任务发生时，比如计时器，网络，事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码，当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。
* 在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行



---

> 任务有优先级吗？

消息队列是有优先级的

根据w3c的最新解释：
* 每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。
* 浏览器必须准备好一个微队列，微队列中的任务优先于所有其他任务执行。


随着浏览器的复杂度急剧提升，w3c，不再使用宏队列的说法。



在目前chrome的实现中，至少包含了下面的队列
1. 延迟队列
  * 主要存放计时器，优先级 中
2. 交互队列
  * 用于存放用户操作后产生的事件处理任务，优先级高
3. 微队列 microtask queue
  * 用于存放需要最快执行的任务，优先级最高
  * 添加到微队列的主要包括：Promise.then/catch/finally 的回调、queueMicrotask、MutationObserver 的回调
  * 在当前主线程执行完后，会检查微队列是否为空，如果为空，则继续执行下一个宏任务，如果微队列不为空，则执行微队列中的任务，直到微队列为空为止。

> Promise 是同步，但是then、catch、finally是异步
 
**执行顺序总结：**
* 首先执行当前主线程中的同步代码
* 然后执行微队列中所有的任务（直到微队列为空）
* 接着在宏任务队列中，浏览器会优先选择交互队列中的任务执行（优先级高）
* 最后执行延迟队列中的任务（优先级中）

这样设计的原因是为了保证用户交互的响应速度。如果微队列任务过多或执行时间过长，可能会阻塞交互队列中的任务执行，导致用户点击页面时有卡顿或无响应的感觉。

> 阐述一下 js的事件循环
* 事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。
* 在chrome的源码中，他开启一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。
* 过去把消息队列简单分为宏任务和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。
* 根据w3c官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务，但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。


**单线程是异步产生的原因**
**事件循环是异步的实现方式**

---

### 宏任务 (macro task)
* script 整体代码块
* setTimeout 
* setInterval
* postMessage
* MessageChannel
* I/O 操作
* UI交互事件（如 click、scroll 等）
* requestAnimationFrame（在浏览器中）

### 微任务(micro task)
* Promise.then/catch/finally 的回调
* queueMicrotask
* MutationObserver 的回调
* process.nextTick（仅在 Node.js 中，优先级最高）


## node
node中的eventloop和浏览器中完全不相同， node用V8引擎作为js解析器，而IO上的处理用了自己设计的libuv
  - libuv是一个基于事件驱动的跨平台抽象层，封装了不同的操作系统一些底层特性，对外提供统一的api
  - libuv 是C++编写的，运行在 Node.js 的主线程（事件循环线程）中，负责处理异步任务。


nodejs的运行机制
* V8引擎解析js脚本
* 解析后的代码，调用node api
* libuv库负责node api的执行。将不同的任务分配给不同的线程，形成一个eventloop。以异步的方式将任务的执行结果返回给V8
* V8再将结果返回给用户
 
### 执行阶段（按顺序执行）
Node.js 事件循环包含以下阶段，按顺序循环执行：

1. **定时器阶段（Timer）**：执行 setTimeout 和 setInterval 的回调
2. **待定回调阶段（Pending Callbacks）**：执行延迟到下一个循环迭代的 I/O 回调
3. **idle, prepare 阶段**：仅内部使用
4. **轮询阶段（Poll）**：获取新的 I/O 事件，执行 I/O 相关的回调
5. **检查阶段（Check）**：执行 setImmediate 的回调
6. **关闭回调阶段（Close Callbacks）**：执行关闭事件的回调（如 socket.on('close', ...)）

**注意：**
* 每个阶段执行完毕后，会检查微任务队列（microtask queue），执行所有微任务
* process.nextTick 的优先级最高，会在每个阶段之间执行
* Node.js 的事件循环会持续运行，直到没有更多的异步操作需要处理

