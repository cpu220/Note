# 堆和栈
Javascript的堆和栈，是两种不同的内存分配方式，影响变量的存储和访问。简单的说，
堆是一个大的、灵活的、动态分配的内存空间。
而栈是一个小的、快速的、有大小限制的内存空间。堆和栈的区别如下：

1. 堆和栈的分配方式不同。堆内存是动态分配的，可以根据需要动态申请和释放内存空间。栈内存也有动态特性（在函数调用时动态增长），但每个线程的栈大小有上限，超出限制会导致栈溢出。
2. 堆和栈的访问速度不同，堆内存的访问速度较慢，因为需要通过指针来寻址。栈内存的访问速度较快，因为直接通过偏移量来定位，且具有良好的局部性。
3. 堆和栈的生命周期不同。在JavaScript中，堆内存由垃圾回收器（GC）自动管理，无需手动申请和释放，垃圾回收器会自动回收不再使用的对象。栈内存的生命周期由系统控制，当函数调用结束时，栈帧会自动回收。
4. 堆和栈的用途不同。栈主要用于存储函数调用信息（调用栈）、局部变量和基本类型值。堆主要用于存储对象、数组等引用类型的数据。

**注意**：这里说的"堆"和"栈"是指内存分配方式，不要与数据结构中的堆（heap data structure，如优先队列）和栈（stack data structure，LIFO结构）混淆。

## 什么数据存放在栈？

栈内存主要存储以下内容：

1. **基本类型的值**（直接存储在栈中）
   - `number`、`string`、`boolean`、`null`、`undefined`、`symbol`、`bigint`
   - 注意：虽然基本类型值存储在栈中，但如果值很大（如很长的字符串），实际数据可能存储在堆中，栈中只存储引用

2. **函数调用信息**（调用栈/执行上下文栈）
   - 函数参数
   - 局部变量
   - 函数的返回地址
   - 当前执行上下文

3. **引用类型的引用（指针）**
   - 变量名和指向堆内存的地址（指针）

``` js
function example() {
  let num = 10;           // 基本类型，值10直接存在栈中
  let str = "hello";      // 基本类型，值"hello"存在栈中（短字符串）
  let flag = true;        // 基本类型，值true存在栈中
  let obj = {a: 1};      // obj变量存在栈中，但存储的是指向堆内存的引用（地址）
                          // 实际对象 {a: 1} 存储在堆内存中
  return obj;
}
// 函数执行完毕后，栈中的局部变量和函数调用信息会被自动清除
```

## 什么数据存放在堆？

堆内存主要存储以下内容：

1. **对象（Object）**
   - 普通对象 `{}`
   - 数组 `[]`（数组也是对象）
   - 函数对象（函数本身是对象）
   - Date、RegExp、Error 等内置对象

2. **复杂数据结构**
   - 闭包中捕获的变量（如果被外部引用）
   - 原型链
   - 对象的方法和属性

``` js
let obj = {              // 对象存储在堆中
  name: "张三",
  age: 20,
  hobbies: ["读书", "游泳"]  // 数组也存储在堆中
};

let arr = [1, 2, 3];     // 数组存储在堆中

function fn() {          // 函数对象存储在堆中
  return "hello";
}

// 闭包示例
function outer() {
  let count = 0;         // count原本在栈中，但被闭包捕获后可能移到堆中
  return function inner() {
    count++;             // 闭包引用的变量会存储在堆中
    return count;
  };
}
```

## 存储示意图

```
栈内存（Stack）                   堆内存（Heap）
┌─────────────┐                  ┌─────────────┐
│ num: 10     │                  │             │
│ str: "hi"   │                  │  {a: 1}     │
│ obj: ───────┼─────────────────>│  [1,2,3]    │
│ arr: ───────┼─────────────────>│  function   │
└─────────────┘                  └─────────────┘
```

## 常见误解澄清

### ❌ 错误理解：对象中的基本类型值存储在栈中

**错误示例：**
``` js
let obj = {
  name: "张三",    // ❌ 错误：认为这个string存储在栈中
  age: 20          // ❌ 错误：认为这个number存储在栈中
};
```

### ✅ 正确理解：对象的所有属性值都存储在堆中

**重要原则：**
- **对象的所有属性值（包括基本类型）都作为对象的一部分存储在堆中**
- **只有独立的、没有被对象包裹的基本类型变量才存储在栈中**

**正确示例：**
``` js
// 情况1：对象中的基本类型值 - 存储在堆中
let obj = {
  name: "张三",    // ✅ 正确：这个string作为对象的一部分存储在堆中
  age: 20          // ✅ 正确：这个number作为对象的一部分存储在堆中
};

// 情况2：独立的基本类型变量 - 存储在栈中
let name = "张三";  // ✅ 正确：独立的string变量存储在栈中
let age = 20;       // ✅ 正确：独立的number变量存储在栈中

// 情况3：对象嵌套对象
let user = {
  name: "张三",           // string存储在堆中（对象的一部分）
  profile: {              // 对象存储在堆中
    email: "zhang@example.com"  // string存储在堆中（嵌套对象的一部分）
  }
};
```

### 存储示意图对比

```
错误理解：
栈内存                   堆内存
┌─────────┐            ┌─────────┐
│ "张三"  │<───────────│ obj     │
│  20     │            │ name ───┼──┐
└─────────┘            │ age  ───┼──┘
                       └─────────┘

正确理解：
栈内存                   堆内存
┌─────────┐            ┌─────────────────┐
│ obj ────┼───────────>│ {                │
│ name ───┼───────────>│   name: "张三"   │ ← string在堆中
│ age ────┼───────────>│   age: 20        │ ← number在堆中
└─────────┘            │ }                │
                       └─────────────────┘
```

## 特殊情况说明

1. **基本类型也可能在堆中**
   - 当基本类型值很大时（如很长的字符串），实际数据可能存储在堆中
   - 当基本类型被闭包捕获且函数已执行完毕时，可能被移到堆中
   - **当基本类型作为对象的属性值时，一定存储在堆中**（因为它们是对象的一部分）

2. **引用类型的变量本身在栈中**
   - 变量名和引用（指针）存储在栈中
   - 实际的对象数据（包括对象的所有属性值）存储在堆中

3. **函数执行上下文**
   - 每个函数调用都会在栈中创建一个执行上下文（栈帧）
   - 执行上下文包含：变量对象、作用域链、this指向等
   - 函数执行完毕后，对应的栈帧会被销毁
