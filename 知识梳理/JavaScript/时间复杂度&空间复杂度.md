
# 时间复杂度和空间复杂度

时间复杂度和空间复杂度是两种用来评估算法效率的重要指标，分别表示算法执行的时间和占用的内存空间与输入规模的关系。通过这两个指标，我们可以客观地比较不同算法的优劣。

## 时间复杂度

时间复杂度是指执行一个算法所需要的计算工作量，它反应了算法的运行速度，即程序执行时间与输入规模之间的函数关系。

### 大O表示法

为了表示不同算法的时间效率，通常采用大O符号（Big O Notation）来描述。在大O表示法中，我们：
- 忽略常数项
- 忽略低次项
- 忽略系数
- 只关注最高次项

**示例**：一个算法的运行时间为 T(n) = 2n² + 3n + 1，则它的时间复杂度为 O(n²)。当n很大时，低次项、常数项和系数对增长趋势的影响可以忽略不计。

### 常见时间复杂度

按照效率从高到低排序：
1. **O(1)** - 常数时间复杂度：无论输入规模多大，执行时间保持不变
2. **O(log n)** - 对数时间复杂度：执行时间随输入规模呈对数增长
3. **O(n)** - 线性时间复杂度：执行时间与输入规模成正比
4. **O(n log n)** - 线性对数时间复杂度：执行时间随输入规模呈线性对数增长
5. **O(n²)** - 平方时间复杂度：执行时间与输入规模的平方成正比
6. **O(n³)** - 立方时间复杂度：执行时间与输入规模的立方成正比
7. **O(2ⁿ)** - 指数时间复杂度：执行时间随输入规模呈指数级增长

### 时间复杂度分析方法

1. **常数阶O(1)**：算法的执行时间不随输入规模变化
   ```javascript
   // 示例：访问数组的第一个元素
   // 时间复杂度：O(1)
   // 分析：无论数组长度如何变化，函数只执行一个简单的数组访问操作，
   // 操作次数是固定的，与输入规模n无关，因此是常数阶时间复杂度
   function getFirstElement(arr) {
     return arr[0]; // 无论数组有多大，都只执行一次操作
   }
   ```

2. **对数阶O(log n)**：算法的执行时间与输入规模的对数成正比，通常出现在每次操作后问题规模减半的算法中
   ```javascript
   // 示例：二分查找
   // 时间复杂度：O(log n)
   // 分析：每次循环后，搜索范围都会减半（left = mid + 1 或 right = mid - 1），
   // 需要执行的循环次数是log₂n，因为n要除以2多少次才能等于1
   // 例如：n=8时，需要3次循环；n=16时，需要4次循环
   function binarySearch(arr, target) {
     let left = 0;
     let right = arr.length - 1; // 初始搜索范围是整个数组
     
     while (left <= right) { // 每次循环将范围减半
       let mid = Math.floor((left + right) / 2);
       
       if (arr[mid] === target) {
         return mid;
       } else if (arr[mid] < target) {
         left = mid + 1; // 搜索右半部分
       } else {
         right = mid - 1; // 搜索左半部分
       }
     }
     
     return -1;
   }
   ```

3. **线性阶O(n)**：算法的执行时间与输入规模成正比
   ```javascript
   // 示例：线性查找
   // 时间复杂度：O(n) - 最坏情况
   // 分析：在最坏情况下（目标不在数组中或在最后一个位置），
   // 需要遍历整个数组，循环执行次数等于数组长度n
   // 平均情况：O(n/2) = O(n)（根据大O表示法忽略常数因子）
   function linearSearch(arr, target) {
     for (let i = 0; i < arr.length; i++) { // 循环执行最多n次
       if (arr[i] === target) {
         return i;
       }
     }
     return -1;
   }
   ```

4. **线性对数阶O(n log n)**：通常出现在分治算法中
   ```javascript
   // 归并排序
   // 时间复杂度：O(n log n)
   // 分析：归并排序采用分治策略，将数组分成两半分别排序，然后合并
   // 1. 分的过程：将数组分成两半，递归深度为log n
   // 2. 治的过程：每次合并两个已排序数组需要O(n)时间
   // 总体时间复杂度 = 递归深度 × 每层合并时间 = O(log n) × O(n) = O(n log n)
   function mergeSort(arr) {
     if (arr.length <= 1) { // 基本情况：数组长度为0或1时已经排序
       return arr;
     }
     
     // 分：将数组分成两半 - O(1)操作
     const mid = Math.floor(arr.length / 2);
     const left = mergeSort(arr.slice(0, mid)); // 递归排序左半部分
     const right = mergeSort(arr.slice(mid)); // 递归排序右半部分
     
     // 治：合并两个已排序数组 - O(n)操作
     return merge(left, right);
   }
   
   // 合并两个已排序数组 - 时间复杂度O(n)，n是两个数组的总长度
   function merge(left, right) {
     let result = [];
     let i = 0;
     let j = 0;
     
     // 比较并合并两个数组 - O(n)操作
     while (i < left.length && j < right.length) {
       if (left[i] <= right[j]) {
         result.push(left[i]);
         i++;
       } else {
         result.push(right[j]);
         j++;
       }
     }
     
     // 处理剩余元素
     return result.concat(left.slice(i)).concat(right.slice(j));
   }
   ```

5. **平方阶O(n²)**：通常出现在嵌套循环中
   ```javascript
   // 示例：冒泡排序
   // 时间复杂度：O(n²)
   // 分析：有两层嵌套循环
   // - 外层循环执行n次
   // - 内层循环在第i次迭代时执行(n-i-1)次
   // 总执行次数 = n-1 + n-2 + ... + 2 + 1 = n(n-1)/2
   // 这是一个二次函数，根据大O表示法，简化为O(n²)
   function bubbleSort(arr) {
     const n = arr.length;
     
     // 外层循环执行n次 - O(n)级别
     for (let i = 0; i < n; i++) {
       // 内层循环执行次数随i增加而减少，但仍然是O(n)级别
       for (let j = 0; j < n - i - 1; j++) {
         if (arr[j] > arr[j + 1]) {
           // 交换元素 - O(1)操作
           [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
         }
       }
     }
     return arr;
   }
   ```

### 时间复杂度分析技巧

1. **忽略常数因子**：O(n) 和 O(2n) 都简化为 O(n)
2. **只关注最高次项**：O(n² + n) 简化为 O(n²)
3. **不同输入规模分开分析**：如果有两个不同的输入规模，如O(n + m)，不能合并为O(n)或O(m)
4. **最坏情况分析**：通常我们分析算法的最坏时间复杂度，即对于任何输入都不会超过的时间复杂度
5. **平均情况分析**：考虑所有可能输入的概率，计算期望的时间复杂度

### 分析示例：三重循环

三重for循环是指在一个for循环中嵌套两个for循环，形成一个三层的循环结构：

```python
for i in range(n):
  for j in range(n):
    for k in range(n):
      # do something
```

**时间复杂度分析**：
- 外层循环执行n次
- 中层循环执行n次
- 内层循环执行n次
- 因此，基本操作的执行次数是 T(n) = n × n × n = n³
- 时间复杂度为 O(n³)

## 空间复杂度

空间复杂度是指执行一个算法所需要的内存空间，它反应了算法的存储开销，即程序运行时占用的空间与输入规模之间的函数关系。空间复杂度分析包括：
- 算法本身的存储空间
- 输入数据占用的存储空间
- 算法运行过程中需要的额外存储空间

### 空间复杂度分析

空间复杂度同样使用大O表示法，并且遵循与时间复杂度相同的忽略规则（忽略常数项、低次项和系数）。通常我们关注的是**额外空间**，即除了输入数据外，算法运行时需要的存储空间。

### JavaScript空间复杂度分析示例

1. **常数空间复杂度 O(1)**：需要的额外空间与输入规模无关

```javascript
// 示例1：数组求和
// 空间复杂度：O(1) - 常数额外空间
// 分析：无论输入数组多大，算法只使用了几个变量（sum, i）来存储中间结果，
// 这些变量的数量是固定的，不随输入规模变化，因此空间复杂度是O(1)
// 注意：输入数组arr本身不计入额外空间复杂度，我们只考虑算法执行过程中需要的额外空间
function sumArray(arr) {
    let sum = 0; // 一个变量，空间复杂度O(1)
    for (let i = 0; i < arr.length; i++) { // i也是一个变量，空间复杂度O(1)
        sum += arr[i];
    }
    return sum;
}

// 示例2：交换数组元素
// 空间复杂度：O(1) - 常数额外空间
// 分析：算法只使用了一个临时变量temp来辅助交换操作，
// 不管数组有多大，额外空间使用量都是固定的
function swap(arr, i, j) {
    let temp = arr[i]; // 一个临时变量，空间复杂度O(1)
    arr[i] = arr[j];
    arr[j] = temp;
}
```

2. **线性空间复杂度 O(n)**：需要的额外空间与输入规模成正比

```javascript
// 示例1：创建数组副本
// 空间复杂度：O(n) - 线性额外空间
// 分析：函数创建了一个新数组newArr，其大小与输入数组arr完全相同，
// 随着输入规模n（数组长度）的增加，额外空间需求线性增长，因此空间复杂度是O(n)
function copyArray(arr) {
    const newArr = []; // 新数组，大小与输入数组相同，空间复杂度O(n)
    for (let i = 0; i < arr.length; i++) {
        newArr.push(arr[i]); // 填充新数组，最终大小为n
    }
    return newArr;
}

// 示例2：将字符串转为数组
// 空间复杂度：O(n) - 线性额外空间
// 分析：函数创建了一个新数组result，用于存储字符串的每个字符，
// 数组长度等于字符串长度n，因此额外空间需求与输入规模成正比
function stringToArray(str) {
    const result = []; // 新数组，空间复杂度O(n)
    for (let i = 0; i < str.length; i++) {
        result.push(str[i]); // 最终数组大小为n
    }
    return result;
}
```

3. **平方空间复杂度 O(n²)**：需要的额外空间与输入规模的平方成正比

```javascript
// 示例：创建二维数组（矩阵）
// 空间复杂度：O(n²) - 平方额外空间
// 分析：函数创建了一个n×n的二维数组，
// 总共需要存储n×n = n²个元素，
// 额外空间需求与输入规模的平方成正比，因此空间复杂度是O(n²)
function createMatrix(n) {
    const matrix = []; // 外层数组
    for (let i = 0; i < n; i++) {
        matrix[i] = []; // 内层数组
        for (let j = 0; j < n; j++) {
            matrix[i][j] = 0; // 填充元素，总共n²个
        }
    }
    return matrix;
}
```

4. **递归算法的空间复杂度**：递归算法的空间复杂度需要考虑递归调用栈的深度

```javascript
// 示例1：简单递归，计算阶乘
// 空间复杂度：O(n) - 线性额外空间
// 分析：递归算法的空间复杂度主要取决于递归调用栈的深度
// 对于factorial(n)，需要从n递归调用到1，
// 调用栈的最大深度为n，因此空间复杂度是O(n)
// 注意：除了调用栈外，这个函数没有使用其他与n成正比的额外空间
function factorial(n) {
    if (n <= 1) return 1; // 基本情况
    return n * factorial(n - 1); // 递归调用，每次n减少1，直到达到基本情况
    // 调用栈深度为n：factorial(n) → factorial(n-1) → ... → factorial(1)
}

// 示例2：递归二分查找
// 空间复杂度：O(log n) - 对数额外空间
// 分析：递归二分查找的调用栈深度等于递归树的高度
// 每次递归调用时，搜索范围减半，因此递归树的高度为log₂n
// 调用栈的最大深度为log n，所以空间复杂度是O(log n)
function recursiveBinarySearch(arr, target, left, right) {
    if (left > right) return -1; // 基本情况
    
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) return mid;
    else if (arr[mid] < target) {
        return recursiveBinarySearch(arr, target, mid + 1, right); // 递归搜索右半部分
    } else {
        return recursiveBinarySearch(arr, target, left, mid - 1); // 递归搜索左半部分
    }
    // 调用栈深度为log n，因为每次调用范围减半
}
```

### 空间复杂度优化技巧

1. **原地算法**：尽可能在原数据结构上进行操作，避免创建新的数据结构
   ```javascript
// 原地反转数组
// 空间复杂度：O(1) - 常数额外空间
// 分析：这是一个原地算法，只使用了两个指针变量（left, right），
// 无论数组多大，额外空间使用量都是固定的，
// 注意：虽然使用了数组解构赋值进行交换，但这不会创建新的数组，只是临时存储交换的值
function reverseArrayInPlace(arr) {
    let left = 0; // 指针变量，空间O(1)
    let right = arr.length - 1; // 指针变量，空间O(1)
    while (left < right) {
        // 交换元素 - 使用解构赋值，但这不会增加额外的空间复杂度
        [arr[left], arr[right]] = [arr[right], arr[left]];
        left++;
        right--;
    }
}
```

2. **避免不必要的递归**：递归可能导致较高的空间复杂度，可以考虑使用迭代替代
   ```javascript
// 迭代版本的阶乘
// 空间复杂度：O(1) - 常数额外空间
// 分析：迭代版本只使用了两个变量（result, i），
// 不管输入n多大，额外空间使用量都是固定的，
// 与递归版本相比，迭代版本避免了递归调用栈的开销
function factorialIterative(n) {
    let result = 1; // 存储结果的变量，空间O(1)
    for (let i = 2; i <= n; i++) { // 循环变量，空间O(1)
        result *= i;
    }
    return result;
}
```

3. **注意JavaScript中的隐式空间**：如闭包、对象等可能占用的空间
   ```javascript
// 闭包示例 - 创建计数器
// 空间复杂度：O(1) - 常数额外空间
// 分析：虽然闭包会捕获外部变量count，但这个变量占用的空间是固定的，
// 不随输入规模变化，因此空间复杂度是O(1)
// 注意：每次调用createCounter()都会创建一个新的闭包，占用独立的空间
function createCounter() {
    let count = 0; // 这个变量会被闭包捕获，占用固定空间
    return function() {
        return ++count; // 访问并修改捕获的变量
    };
}
```

## 时间与空间的权衡

在实际编程中，我们常常需要在时间复杂度和空间复杂度之间进行权衡：

- **时间换空间**：通过增加额外的存储空间来减少算法的执行时间
- **空间换时间**：通过减少使用的存储空间来换取更节省内存的算法

选择哪种策略取决于具体的应用场景和资源限制。
 