# 继承

继承是面向对象的概念，它描述了两个对象类型（类，构造函数）之间的关系
如果在逻辑上可以描述为： B的实例一定是A的实例（is-a关系），但A的实例不一定是B的实例，则B继承A、A派生B、A是B的父类，B是A的子类


**子类的实例应该自动拥有父类的所有成员**

## 什么是构造函数？

**构造函数（Constructor）** 是用来创建和初始化对象的特殊函数。在 JavaScript 中，任何函数都可以作为构造函数使用，但通常构造函数名首字母大写以区分普通函数。

### 构造函数的特点：

1. **用于创建对象**：通过 `new` 关键字调用构造函数来创建对象实例
2. **初始化对象**：在构造函数内部使用 `this` 来设置新对象的属性
3. **自动返回对象**：构造函数会自动返回创建的对象实例（除非显式返回其他对象）

> 箭头函数没有 prototype 属性，所以不能作为构造函数使用。
> 箭头函数的诞生，就是为了解决this指向问题，所以没有this、arguments、new.target ， 如果使用了，则使用的事函数外层对应的 this、arguments、new.target
```js
const fn = ()=>{
    console.log(this)
}
fn() // 报错 Uncaught TypeError: a is not a constructor
```



### 构造函数的基本用法：

```js
// 定义一个构造函数（首字母大写是约定）
function User(username, password) {
    // this 指向新创建的对象实例
    this.username = username;
    this.password = password;
}

// 使用 new 关键字调用构造函数创建实例
const p = new User('张三', '123456');
console.log(p); // { username: '张三', password: '123456' }
```

### new 关键字做了什么？

当使用 `new` 调用构造函数时，JavaScript 会执行以下步骤：

1. **创建新对象**：创建一个空对象
2. **设置原型链**：将新对象的 `__proto__` 指向构造函数的 `prototype`
3. **绑定 this**：将构造函数内部的 `this` 指向新创建的对象
4. **执行构造函数**：执行构造函数内部的代码，初始化对象属性
5. **返回对象**：如果构造函数没有显式返回对象，则返回新创建的对象

```js
// new 的执行过程（详细演示版）
function User(username, password) {
    this.username = username;
    this.password = password;
}

// 在 User.prototype 上添加方法
User.prototype.sayHello = function() {
    console.log(`Hello, ${this.username}`);
}

// ========== 步骤1：创建新对象 ==========
const p = {};  // 创建一个空对象
console.log('步骤1 - 创建空对象:', p); // {}
console.log('步骤1 - p.__proto__:', p.__proto__); // Object.prototype

// ========== 步骤2：设置原型链 ==========
// 将新对象的 __proto__ 指向构造函数的 prototype
Object.setPrototypeOf(p, User.prototype);  // 等同于 p.__proto__ = User.prototype
console.log('步骤2 - 设置原型链后 p.__proto__ === User.prototype:', p.__proto__ === User.prototype); // true
console.log('步骤2 - p.__proto__.constructor === User:', p.__proto__.constructor === User); // true
console.log('步骤2 - p 现在可以访问 User.prototype 上的方法:', typeof p.sayHello); // 'function'

// ========== 步骤3：绑定 this 并执行构造函数 ==========
// 将构造函数内部的 this 指向新创建的对象，并执行构造函数
User.call(p, '张三', '123456');  // 等同于执行：p.username = '张三'; p.password = '123456';
console.log('步骤3 - 执行构造函数后 p:', p); // { username: '张三', password: '123456' }
console.log('步骤3 - p.username:', p.username); // '张三'
console.log('步骤3 - p.password:', p.password); // '123456'

// ========== 步骤4：返回对象 ==========
// 如果构造函数没有显式返回对象，则返回新创建的对象
// 这里 User 构造函数没有 return 语句，所以返回 p
console.log('步骤4 - 最终对象:', p); // { username: '张三', password: '123456' }
console.log('步骤4 - 原型链关系:', p.__proto__ === User.prototype); // true
console.log('步骤4 - constructor 指向:', p.constructor === User); // true

// ========== 验证：使用 new 关键字的结果 ==========
const p2 = new User('李四', '789012');
console.log('使用 new 创建的对象:', p2); // { username: '李四', password: '789012' }
console.log('p2.__proto__ === User.prototype:', p2.__proto__ === User.prototype); // true
console.log('p2.__proto__ === p.__proto__:', p2.__proto__ === p.__proto__); // true (共享同一个 prototype)
console.log('p2.constructor === User:', p2.constructor === User); // true

// ========== 原型链关系图 ==========
// p {
//   username: '张三',
//   password: '123456',
//   __proto__: User.prototype {
//     sayHello: function,
//     constructor: User,
//     __proto__: Object.prototype {
//       __proto__: null
//     }
//   }
// }
```

**关键点说明：**

1. **步骤1**：创建空对象 `{}`，此时 `p.__proto__` 默认指向 `Object.prototype`
2. **步骤2**：设置 `p.__proto__ = User.prototype`，建立原型链关系
3. **步骤3**：通过 `User.call(p, ...)` 将 `this` 绑定到 `p`，执行构造函数代码
4. **步骤4**：返回对象 `p`（如果构造函数没有显式返回其他对象）

**原型链关系：**
```
p (实例对象)
  ↓ __proto__
User.prototype (构造函数的原型)
  ↓ __proto__
Object.prototype
  ↓ __proto__
null
```

### 构造函数 vs 普通函数

```js
// 构造函数（通常首字母大写）
function User(name) {
    this.name = name;
}

// 普通函数（通常首字母小写）
function sayHello(name) {
    console.log(`Hello, ${name}`);
}

// 使用 new 调用构造函数 → 创建对象
const p = new User('张三'); // { name: '张三' }

// 不使用 new 调用构造函数 → 普通函数调用（this 指向全局对象或 undefined）
const p2 = User('李四'); // undefined（没有返回值），且可能污染全局作用域

// 普通函数调用
sayHello('王五'); // Hello, 王五
```

### 内置构造函数

JavaScript 提供了许多内置构造函数：

```js
// 内置构造函数示例
const arr = new Array(1, 2, 3);  // [1, 2, 3]
const obj = new Object();        // {}
const date = new Date();         // 当前日期时间
const str = new String('hello'); // String 对象

// 字面量写法（更简洁，底层也是调用构造函数）
const arr2 = [1, 2, 3];          // 等价于 new Array(1, 2, 3)
const obj2 = {};                 // 等价于 new Object()
const str2 = 'hello';            // 原始值，不是对象
```

继承具有两个特性
- 单根性: 子类只能有一个父类
- 传递性: 如果A是B的父类，B是C的父类，则A是C的父类。 间接父类的成员会传递到子类中

## prototype 和 __proto__ 的区别

### prototype（显式原型）
- **所有者**：只有**函数**才有 `prototype` 属性
- **作用**：用于存放该构造函数创建的所有实例共享的属性和方法
- **标准性**：ECMAScript 标准属性
- **访问方式**：`函数名.prototype`

```js
function User() {}
console.log(User.prototype); // { constructor: User }

// 普通对象没有 prototype
const obj = {};
console.log(obj.prototype); // undefined
```

### __proto__（隐式原型）
- **所有者**：**所有对象**都有 `__proto__` 属性 // 因为所有对象都是由构造函数创建的
- **作用**：指向创建该对象的构造函数的 `prototype` 
- **标准性**：**非标准属性**（浏览器实现的便利属性，不是 ECMAScript 标准）
- **访问方式**：`对象.__proto__` 或使用标准方法 `Object.getPrototypeOf(对象)`

```js
function User() {}
const p = new User();

// 实例的 __proto__ 指向构造函数的 prototype
console.log(p.__proto__ === User.prototype); // true

// 使用标准方法获取原型（推荐）
console.log(Object.getPrototypeOf(p) === User.prototype); // true
```

### constructor（构造函数属性）

`constructor` 是 `prototype` 对象上的一个属性，它指向创建该原型对象的构造函数本身。

**特点：**
- **位置**：存在于 `prototype` 对象上（即 `函数名.prototype.constructor`）
- **默认值**：默认指向该构造函数本身
- **作用**：用于标识创建该对象的构造函数，可以通过实例访问到构造函数

```js
function User() {}

// User.prototype 默认有一个 constructor 属性，指向 User
console.log(User.prototype.constructor === User); // true

- 所以，任何普通函数的的原型链上，都会默认有一个构造器的属性constructor， 这个constructor 默认会指向该函数本身
- 函数本身也是一种对象，所有的函数都是由 Function这个内置的构造函数创建的。因此，所有函数的原型链，最终都会指向Function.prototype
- 并且，Function.prototype.constructor 指向 Function 自身


const p = new User();

// 实例可以通过 __proto__ 访问到 constructor
console.log(p.__proto__.constructor === User); // true
console.log(p.constructor === User); // true (通过原型链访问)

// 可以通过 constructor 创建新实例
const p2 = new p.constructor('新用户'); // 等同于 new User('新用户')
```

**是否存在，User.prototype.constructor 不指向User自身？**

```js
User.prototype = {
  sayHi: function() { console.log('hi'); }
};
console.log(User.prototype.constructor === User); // false
console.log(User.prototype.constructor === Object); // true（因为新对象是 Object 的实例）

```

```js
function Admin() {}
User.prototype = {
  constructor: Admin // 显式设置为 Admin
};

console.log(User.prototype.constructor === Admin); // true（指向了其他函数）
```
手动修改constructor指向，就会出现constructor不指向自身的情况


**为什么需要修复 constructor？**

在实现继承时，当我们使用 `Object.create()` 创建新的原型对象时，新对象的 `constructor` 会指向父类构造函数，而不是子类构造函数。因此需要手动修复。

```js
function User() {}
function VIPUser() {}

// 使用 Object.create 创建新原型对象
VIPUser.prototype = Object.create(User.prototype);

// 此时 constructor 指向的是 User，而不是 VIPUser
console.log(VIPUser.prototype.constructor === User); // true 
console.log(VIPUser.prototype.constructor === VIPUser); // false 

// 需要手动修复 constructor 指向
VIPUser.prototype.constructor = VIPUser;
console.log(VIPUser.prototype.constructor === VIPUser); // true ✅
```

**不修复 constructor 会有什么问题？**

1. **类型判断错误**：`instance.constructor` 会错误地指向父类
2. **无法通过 constructor 创建正确的实例**：使用 `new instance.constructor()` 会创建父类实例而不是子类实例

```js
function User() {}
function VIPUser() {}

VIPUser.prototype = Object.create(User.prototype);
// 没有修复 constructor

const p = new VIPUser();
console.log(p.constructor === VIPUser); // false ❌
console.log(p.constructor === User); // true ❌ (错误！)

// 尝试通过 constructor 创建实例
const p2 = new p.constructor(); // 创建的是 User 实例，而不是 VIPUser 实例！
```

### 为什么不能直接使用 __proto__？

`__proto__` 虽然大多数浏览器都支持，但存在以下问题：

1. **非标准属性**：不是 ECMAScript 官方标准，只是浏览器厂商实现的便利属性
2. **兼容性问题**：某些环境可能不支持（如旧版 IE、严格模式下的某些情况）
3. **性能问题**：直接修改 `__proto__` 会导致性能下降，因为会触发原型链的重新计算

**推荐的标准方式：**
- **获取原型**：使用 `Object.getPrototypeOf(obj)` 替代 `obj.__proto__`
- **设置原型**：使用 `Object.create(prototype)` 或 `Object.setPrototypeOf(obj, prototype)` 替代 `obj.__proto__ = prototype`

```js
// ❌ 不推荐：使用非标准的 __proto__
VIPUser.prototype.__proto__ = User.prototype;

// ✅ 推荐方式1：使用 Object.create (性能最好，创建新对象)
VIPUser.prototype = Object.create(User.prototype);
VIPUser.prototype.constructor = VIPUser; // 记得修复 constructor！

// ✅ 推荐方式2：使用 Object.setPrototypeOf (可以工作，但性能较差)
Object.setPrototypeOf(VIPUser.prototype, User.prototype);
VIPUser.prototype.constructor = VIPUser; // 也需要修复 constructor！
```

```js


function User (username,password){
     this.username = username;
     this.password = password;
 }

User.prototype.payFreeVideo = function(){
    console.log(`${this.username}免费看视频`)
}


function VIPUser(username,password,level){
    User.call(this,username,password)
    this.level = level;
}

 
// ❌ 不推荐：直接使用 __proto__（非标准属性，兼容性和性能问题）
// VIPUser.prototype.__proto__ = User.prototype

// ✅ 方式1：使用 Object.create (推荐，性能更好)
// Object.create 会创建一个新对象，其 __proto__ 指向 User.prototype
VIPUser.prototype = Object.create(User.prototype)
VIPUser.prototype.constructor = VIPUser // 修复constructor指向

// ✅ 方式2：使用 Object.setPrototypeOf (可以工作，但性能较差)
// Object.setPrototypeOf 会修改现有对象的原型链
// Object.setPrototypeOf(VIPUser.prototype, User.prototype)

VIPUser.prototype.playPayVideo = function(){
    console.log(`${this.username}付费看VIP视频`)
}


const p = new User('张三','123456') // {username: '张三', password: '123456'}
const p2 = new VIPUser('李四','123456','VIP1') //  {username: '李四', password: '123456', level: 'VIP1'} 

// 验证继承是否成功
p2.payFreeVideo() // 李四免费看视频 (继承自父类)
p2.playPayVideo() // 李四付费看VIP视频 (子类自己的方法)
console.log(p2 instanceof VIPUser) // true
console.log(p2 instanceof User) // true (继承关系验证)

// 验证 constructor 是否正确
console.log(p2.constructor === VIPUser) // true (constructor 已正确修复)
console.log(p2.constructor === User) // false (不会错误地指向父类)


```


```js

// 完整的继承函数
function inherit(child, parent){
    // 创建新对象，原型指向父类的prototype
    child.prototype = Object.create(parent.prototype)
    // 修复constructor指向
    child.prototype.constructor = child
}

// 使用示例
inherit(VIPUser, User)
// 注意：使用inherit函数后，还需要在子类构造函数中调用父类构造函数
// function VIPUser(username,password,level){
//     User.call(this,username,password)  // 这一步仍然需要
//     this.level = level;
// }

```