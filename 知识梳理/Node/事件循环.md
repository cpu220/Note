# nodejs 与浏览器的【事件循环】有何区别

## 进程和线程

Javascript是一门【单线程】的语言， 指的是一个进程里只有一个主线程

### 进程
cpu 资源分配的最小单位

### 线程
cpu 调度的最小单位

### 类比的话
- 进程就好比是一个工厂， 线程就好比是工厂里的工人，而且是对应工程的专属工厂资源。
- 多个人在一个工厂中协作工作，工厂和工人的关系是 1：n的关系。 也就是一个进程由多个线程组成，现成是一个进程中代码的不同执行路线
- 工厂的空间是工人们共享的，这意味着，一个进程的内存空间是共享的，每个现成都可以用这些共享内存。
- 但是，多个工厂之间独立存在。 

### 多进程

在同一时间里，多一个计算机系统中，如果允许 【两个】 或 【两个以上】的进程处于运行状态。 相互之间不会影响

### 多线程
程序中包含多个执行流，即在一个程序中可以同时运行【多个】现成来执行不同的任务，也就是说，允许单个程序创建多个并执行的线程来完成各自的任务

## 浏览器内核
浏览器内核是通过取得页面内容、整理信息、计算和组合最终输出可视化图像结果，通常也被成为渲染引擎。

浏览器内核是多线程，在内核的控制下，各现成相互配合以保持同步，一个浏览器通常由以下常驻线程组成：
- GUI渲染线程
- Javascript引擎线程
- 定时触发器线程
- 事件触发线程
- 异步http请求线程

### GUI 渲染线程
- 主要负责页面的渲染，解析HTML、css， 构建DOM树，布局和绘制等。
- 当界面需要重绘，或者由于某种操作引发回流时，将执行该线程。
- 该线程与js引擎线程互斥，当执行js引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。

### Javascript引擎线程
- 该线程主要负责处理 Javascript 脚本，执行代码
- 也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 js 引擎线程的执行。
- 注意的是，js线程和GUI渲染线程是互斥的，所以当js脚本执行时间过长，页面渲染就会阻塞。

### 定时触发器
- 负责执行异步定时器一类的函数的线程：setTimeout、setInterval
- 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待js引擎执行。

### 事件触发线程
- 助于奥负责将准备好的事件，交给js引擎执行

比如 setTimeout 定时器计数结束，ajax等异步请求成功并处罚回调函数，或者用户触发点击事件时，该线程会将 准备好的事件依次加入到任务队列的对位，等待js引擎线程执行。

### 异步 http 请求线程
- 负责执行异步请求一类的函数线程，比如 promise，fetch，ajax等。
- 主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的队尾，等待js引擎线程执行。


# 浏览器中的事件循环

## 宏任务(macro task)和微任务(micro task)

### 宏任务
- 包括 【script】 脚本，【setTimeout】 定时器，【setInterval】 定时器，【I/O】 操作，【UI渲染】 , requestAnimationFrame 等。
### 微任务
- 包括 【Promise】 回调，【async/await】 回调，【MutationObserver】 回调等。Process.nextTick 是一个特殊的微任务，它的优先级高于其他微任务。   


事件循环流程
1. 一开始执行栈为空，我们可以把执行栈认为是一个储存函数调用的栈结构，遵循先进后出的原则。微任务队列为空，宏任务队列有且只有一个 script 脚本（整体代码）
2. 全局上下文（script标签） 被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的宏任务与微任务，它们会被推入各自的任务队列里。 同步代码执行完了，script脚本会被移出宏任务队列，这个过程本质上是队列的宏任务执行的出队过程。
3. 当出队一个宏任务后，开始处理微任务队列。直到将整个微任务队列清空。
4. 执行渲染操作，更新界面
5. 检查是否存在web worker任务，如果有，则对其进行处理
6. 重复以上步骤，直到宏任务队列为空，微任务队列为空，事件循环结束。


> 一个宏任务-> 清空微任务队列->执行渲染操作->检查web worker任务-> 执行下一个宏任务


# Nodejs 中的事件循环
> nodejs的事件循环与web浏览器的事件循环是不同的。
nodejs 用的v8 作为js 的解析引擎，而I/O处理方面使用了自己设计的libuv
而libuv 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现。


nodejs的事件循环比浏览器复杂很多，大体如下：
1. v8 引擎解析Javascript脚本。
2. 解析后的代码，调用nodejs api
3. libuv库 负责 Node API的执行。它将不同的任务分配给不同的线程，形成一个事件循环，以【异步的方式】将任务的结果返回给V8 引擎
4. v8 引擎再将任务结果返回给用户


## 事件循环的 6 个阶段
- libuv引擎中的事件循环分为6个阶段，它们会按照顺序反复运行。
- 每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。
- 当对垒为空，或者执行的回调函数数量达到系统设定的阙值，就会进入下一个阶段。

事件循环的顺序：
1. 外部数据输入
2. 轮训阶段(poll)
3. 检查阶段(check)： 执行setImmediate 回调
4. 关闭事件回调阶段(close callback)：执行 socket的close 事件回调
5. 定时器检查阶段(timer) ：执行timer的回调（setTimeout, setInterval）
6. I/O 事件回调阶段(I/O callbacks)  ： 处理上一轮循环中，少数未执行的I/O 回调
7. 闲置阶段(idle, prepare) ：  仅Nodejs内部使用
8. 轮训阶段(poll): 获取新的I/O 事件，适当的条件下会阻塞在这个阶段


核心是6个阶段
timer->I/O-> idle/perpare -> poll -> check -> close callback

> 注意:  上面6个阶段都不包括 process.nextTick()
> 其实重点是 timer、poll、check 这3个阶段

### timer 阶段

timer阶段会执行 setTimeout 和 setInterval 定时器的回调函数。并且是由poll阶段控制的。
同样在nodejs中，定时器指定的时间也不是准确的事件，只是尽快执行。

### poll 阶段

poll 是一个至关重要的阶段，这个阶段会做两件事情
- 回到timer阶段执行回调
- 执行I/O 回调

并且在进入该阶段时，如果没有设定timer，会发生下面两件事情。
- 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空 或者 达到系统限制
- 如果 poll 队列为空时，又会有下面两件事发生:
  - 如果 setImmediate回调需要执行，poll 阶段会停止并进入到check 阶段执行回调
  - 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中，并立即执行回调，这里同样会有个超时时间设置，防止一直等待下去。
  
```js
if(setImmediate){
    // poll 阶段会停止并进入到check 阶段执行回调
}else {
    // 回调被加入到队列中，并立即执行回调，这里同样会有个超时时间设置，防止一直等待下去。
}


```

如果设定了timer，并且poll 队列为空，则会判断timer是否超时，如果超时，就会回到timer阶段

如果poll 被堵塞，那么即使timer已经到了时间，也只能继续等待，所以定时器的事件并不准确、、、


## check 阶段
setImmediate  回调会被加入到check 队列中

```js

console.log('start')
setTimeout(()=>{
    console.log('timer1')
    Promise.resolve().then(()=>{
        console.log('promise1')
    })
},0)

setTimeout(()=>{
    console.log('timer2')
    Promise.resolve().then(()=>{
        console.log('promise2')
    })
},0)

Promise.resolve().then(()=>{
    console.log('promise3')
})

console.log('end')


//  输出结果： start -> end -> promise3-> timer1 -> promise1 -> timer2->promise2
```

```js

setTimeout(()=>{
    console.log('timer3')
},0)

setImmediate(()=>{
    console.log('immediate1')
})

// 输出结果： immediate1 -> timer3
```

注意，setImmediate 因为是在check阶段执行，所以永远比 setTimeout 快
 

## process.nextTick()

process。nextTick 这个函数，是独立于事件循环之外的，它有一个自己的队列。当每个阶段完成后，如果存在nextTick队列，就会清空队列的所有回调函数，并且优先于其他 microtask 执行。

```js
setTimeout(()=>{
    console.log('timer1')
    Promise.resolve().then(()=>{
        console.log('promise1')
    })
},0)


process.nextTick(()=>{
    console.log('nextTick1')
    process.nextTick(()=>{
        console.log('nextTick2')
        process.nextTick(()=>{
            console.log('nextTick3')
            // ...
        })
    })
})

// nextTick1 -> nextTick2 -> nextTick3 -> timer1 -> promise1

```
 

# 总结

浏览器的事件循环，是每完成一个宏任务，就会清空一次微任务队列。
Nodejs的事件循环，是每个任务队列的每个任务执行完毕后，就会清空微任务队列。