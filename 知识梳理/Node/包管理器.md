# npm
> Node.js 自带，最基础，生态完整的包管理器。所有包都支持npm安装

## 优势
- 装Node就有，不用额外配置
- 生态全，所有npm仓库的包都支持
- 兼容性最好，问题也容易搜到，社区成熟
- 最新版npm（v9+）已经支持自动修复依赖漏洞
## 劣势
- 慢：由于安装依赖是**串行+嵌套依赖**，会导致重复依赖多（比如A和B都依赖C，那么就会安装两份C）
- 占空间：重复依赖导致磁盘占用大
- 锁文件不稳定：早期（npm5之前，没有lock文件）；但现在偶尔会有bug，有lock文件也没什么用
- 存在幽灵依赖：未在 package.json 声明的包也能被代码引用；该现象由依赖扁平化提升导致，与缓存无关，清除缓存无法解决

## 最新特性
- npm workspaces：支持monorepo管理
- npm audit：自动检查并修复依赖安全漏洞
- npm dedupe：移除重复依赖
- npm ci：用于CI环境，严格按照lock文件安装

# yarn
> 16年 Facebook等公司推出，初衷是为了解决npm的问题

## 优势
- 比早期的npm快，支持**并行安装**，同时下载多个依赖
- 锁文件稳定，有lock文件
- 支持离线缓存
- 支持monorepo，yarn workspaces成熟

## 劣势
- npm7已经借鉴了yarn的很多特性，比如支持了并行安装、锁文件优化等，所以yarn现在的优势不明显
- 缓存偶尔会版本不一致，需要手动清理缓存

## 最新特性
- Yarn Berry（v2+）：全新架构，使用Plug'n'Play模式，不再生成node_modules目录
- Yarn Plug'n'Play：依赖以zip包形式存储，通过映射表直接访问，大幅提升性能
- Yarn Zero-Installs：将依赖直接提交到版本控制，无需安装即可运行
- Yarn Constraints：支持在monorepo中强制执行依赖版本约束

# pnpm
> 17年推出，用**硬链接+符号链接**重构了依赖存储，解决了npm、yarn的重复依赖、占空间的痛点
- 硬链接：指向同一个文件的多个路径，占用空间小，更新时只需要更新一个文件
- 符号链接：指向另一个文件的路径，占用空间小，更新时只需要更新一个文件

## 优势
- 快：并行安装+共享依赖，速度超过npm、yarn
- 省空间：所有项目共享一个依赖缓存（比如A和B都依赖C，那么只会装一个C，通过链接引用），所以磁盘占用小
- 依赖隔离：每个项目的依赖都是独立的，不会相互干扰，避免幽灵依赖（比如没在package.json里声明的依赖，意外能使用的情况）
- 支持monorepo，pnpm workspaces成熟

## 劣势
- 兼容有问题，因为链接的机制，少数写死本地路径的包无法使用；不过这个问题可以忽略不计
- 需要额外安装，Node.js不自带

## 最新特性
- pnpm publish --provenance：生成软件供应链安全证明
- pnpm install --frozen-lockfile：严格按照lock文件安装，适合CI环境
- pnpm dlx：临时执行一个命令，无需全局安装
- 内置的依赖隔离功能，自动检测并避免依赖冲突
  

# 幽灵依赖
> 这个是开发中经常遇到的问题，明明没有安装某个依赖，但是项目中能正常使用。或者项目开发时候没有问题，但是打包提示缺少某个依赖。

导致这个问题的核心原因是，npm和yarn为了解决嵌套依赖冗余，而设计的**依赖扁平化提升机制**（hoisting）。

## 扁平化提升的工作逻辑
- 解析依赖树时，会把所有子依赖提升到项目根目录的node_modules下，这样所有父依赖都能共享一个版本，避免重复安装，节省空间，提速。

比如，项目引用了A，A的依赖是B。
那么扁平化后，A和B都会在node_modules根目录下。于是在项目里可以直接调用B，但package.json里没有声明。

所以，幽灵依赖的本质是扁平化提升，破坏了依赖声明与实际可访问性的一致性，超出了父依赖私有依赖的边界，变成了整个项目的**共享依赖**，但项目没有声明。

## 幽灵依赖的潜在问题
1. **版本冲突风险**：如果两个依赖包内部使用了同一个包的不同版本，提升后只有一个版本会生效，可能导致隐藏的兼容性问题
2. **构建失败**：开发环境能正常运行，但构建时提示缺少依赖（因为打包工具可能严格检查package.json中的声明）
3. **依赖断裂**：当间接依赖的版本更新或被移除时，会导致项目中直接使用该依赖的代码崩溃
4. **代码质量问题**：使用未声明的依赖不符合良好的工程实践，增加了项目的维护成本

## 为什么和缓存无关？
缓存的作用是**储存已下载的依赖包，避免重复下载**，它只影响【依赖的下载速度和存储位置】，不改变node_modules的目录结构。

## 为什么pnpm没有幽灵依赖？
因为pnpm没有采用扁平化提升，而是用硬链接+符号链接的非扁平化结构，从根源上避免了幽灵依赖

1. **严格的依赖隔离**：根目录node_modules中，只存放你在package.json中明确声明的依赖，子依赖不会被提升
2. **内容寻址存储**：子依赖会存储在全局缓存中（基于内容寻址），通过硬链接确保文件内容只存储一次，节省空间
3. **符号链接结构**：父依赖通过符号链接访问其需要的子依赖，但这些子依赖对项目代码不可见
4. **模块查找机制**：node模块查找时，只能找到声明的依赖及其正确嵌套的子依赖，找不到未在package.json中声明的间接依赖，从结构上杜绝了幽灵依赖

这种设计确保了依赖的严格可见性，使得项目只能访问package.json中声明的依赖，从而避免了幽灵依赖问题