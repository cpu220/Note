# 异步渲染 

## 1. 时间切片 time slicing

在react渲染的时候，会将任务拆成多个小任务，这些细分的任务，则会在主线程空闲的时候执行，在执行任务的期间，随时可以进行暂停。

当然，使用时间切片的缺点，是任务的总时间变长了，因为它每处理完一个小任务后，主线程会空闲出来，并且在下一个小任务开始处理之前，有一小段的延迟。为了避免浏览器卡死，这种取舍就显得必要。


这里有个远程的API， requestIdleCallback， 
* react是使用了原生的API，但是对它进行了一定程度的封装和优化，react的调度器，（scheduler）模块就是基于requestIdleCallback实现的。它可以根据任务的优先级来安排执行实现，从而提高性能和用户体验。
* 对于不支持的浏览器，也使用了setTimeout来模拟，使用MessageChannel来实现微任务队列，


## 2. 悬停或者暂停（suspense）
调用 render -》 发现有异步请求-》 悬停
等待异步请求结果-》 再渲染展示数据

细化流程

1. 在render函数中，我们可以写入一个异步请求，请求数据
2. render会从我们缓存中读取这个缓存
3. 如果有缓存，那直接正常进行render
4. 如果没有缓存，那么会抛出一个异常，这个异常是一个promise
    * 为什么要用异常来实现？
    *  这个异常会被react捕获，然后react会暂停渲染，等待异步请求结果
5. 当这个Promise完成后，react会继续回到原来的render中，也就是重新执行一遍，把数据render出来

