React性能优化

# eagerState

在React中，有很多性能优化相关的API和策略：

- 组件优化API：shouldComponentUpdate、PureComponent、React.memo
- Hooks优化API：useMemo、useCallback
- 内部优化策略：eagerState、bailout

实际上，开发者调用这些API，本质上是在帮助React命中其内部的性能优化策略。

React内部有两大核心优化策略：eagerState和bailout，下面将详细介绍这些策略及其工作原理。

## 案例一

``` jsx
import {useState} from 'react'

// 子组件
function Child (){
    console.log('child render')
    return (
        <div>
            <p>child</p>
        </div>
    )
}

// 父组件
function App (){
    const [num,updateNum] = useState(0)
    console.log('app render',num)
    return (
        <div>
            <p onClick={()=>updateNum(1)}>app</p>
            <Child /> {/* React组件名必须大写 */}
        </div>
    )
} 

export default App  

```

上面代码执行结果如下：
- 初始化第一次：
```
app render 0
child render
``` 
- 点击后第二次渲染：
```
app render 1
child render
```

- 点击后第三次渲染：
```
app render 1 
```

- 点击后第四次及更多次，没有任何输出


上面的案例涉及到了React内部的两种性能优化策略：
- 第二次渲染时，仍然打印了child，因为我们没有使用React.memo优化Child组件。如果使用React.memo包装Child组件，第二次渲染时子组件可能会被优化。
- 第三次渲染时，父组件仍然渲染但子组件不再渲染，这是因为父组件没有命中bailout策略，但在第三次渲染过程中，由于状态没有变化，可能会在后续的更新中命中eagerState策略。
- 第四次及之后的点击没有任何输出，说明App和Child组件都没有进入render阶段，这是命中了eagerState策略。这是一种发生于**触发状态更新时**的优化策略，如果命中该策略，此次更新不会进入scheduler阶段，后续的render和commit阶段自然也不会执行

## eagerState 策略
> eagerState策略的核心逻辑是：如果某个状态的更新前后没有变化，那么就可以跳过后续的更新流程。
> state的更新通常是基于组件update进行计算，计算过程发生在render阶段的beginWork。而eagerState策略将这个计算过程提前到了schedule之前执行，从而更早地判断是否需要更新。
> 该策略的前提条件是：当前的FiberNode不存在高优先级的更新等待执行。具体判断条件为`fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)`，这确保了当前Fiber和其alternate都没有优先级标记，可以安全地进行提前计算。


例如，在使用useState触发更新时，对应的dispatchSetState更新逻辑的核心部分如下：

```js
if(
    fiber.lanes === NoLanes && 
    (alternate === null || alternate.lanes === NoLanes)
){
    // 队列当前没有优先级标记，这意味着可以在进入渲染阶段之前，计算下一个状态
    // 如果新状态与当前状态相同，那么就可以直接跳过后续的更新流程
    const lastRenderedReducer = queue.lastRenderedReducer;
    if(lastRenderedReducer !== null){
        try{
            const currentState = queue.lastRenderedState; // 获取当前状态
            const eagerState = lastRenderedReducer(currentState, action); // 基于action，提前计算下一个状态
            
            // 将预先计算的状态和使用的reducer存储在update对象上
            update.hasEagerState = true;
            update.eagerState = eagerState;
            
            if(is(eagerState, currentState)){
                // 如果新状态与当前状态相同，那么就可以直接跳过后续的更新流程
                update.hasEagerState = false;
                update.eagerState = null;
                return;
            }
        }catch(err){
            // 错误处理
        }
    }
}

```

在上面的代码中，React首先通过lastRenderedReducer提前计算state，然后在当前update对象上进行标记。之后使用is函数（类似于Object.is）比较eagerState和currentState，如果状态没有变化，就命中了eagerState策略，直接跳过后续的更新流程，不会进入scheduler阶段。

即便状态发生了变化，提前计算的eagerState也有价值，因为它可以作为后续更新的基础，减少重复计算。

即使状态发生了变化（is函数返回false），提前计算的eagerState仍然有价值，因为它可以作为后续更新的基础state使用，减少重复计算。

这就是为什么函数组件（FC）类型的update对象中会有hasEagerState和eagerState字段。它们用于存储提前计算的状态信息，优化更新性能。

```js
update = {
    hasEagerState: false, // 标记是否有提前计算的状态
    eagerState: null,     // 存储提前计算的状态值
    // ...其他字段
};

在上面的案例中，为什么第二次点击时num已经为1的情况下，父组件还会再次渲染？

这是因为eagerState策略的判断条件涉及Fiber树中的两个版本：current（当前已渲染的Fiber）和wip（work-in-progress，正在构建的Fiber）。判断条件要求两者的lanes都为NoLanes：

```js
fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)
```

具体过程如下：
- 第一次更新时，beginWork开始前，current.lanes和wip.lanes都不是NoLanes
- beginWork执行后，wip.lanes被重置为NoLanes，但current.lanes保持不变
- commit阶段完成后，wip和current会进行交换，导致第二次更新时current.lanes不为NoLanes，因此无法命中eagerState策略

至于为什么第三次及之后的点击又能命中eagerState策略？

这是因为第二次更新时虽然没有命中eagerState策略，但命中了bailout策略。对于命中bailout策略的函数组件，React会执行bailoutHooks方法：

```ts
function bailoutHooks(
    current: Fiber,
    workInProgress: Fiber,
    lanes: Lanes,
){
    workInProgress.updateQueue = current.updateQueue;
    // 移除当前FiberNode的lanes
    current.lanes = removeLanes(current.lanes, lanes);
    workInProgress.lanes = NoLanes;
}
```

通过bailoutHooks方法，React移除了current.lanes中的相关优先级标记。这样，当第二次更新完成后，current.lanes和wip.lanes都会变为NoLanes，因此在后续的点击中就能满足eagerState策略的条件，从而命中该策略。

## bailout策略

bailout是React在render阶段的一种优化策略，当组件的props和state没有变化时，可以跳过该组件及其子组件的reconcile过程。
 
首先，beginwork的主要作用是生成 wip。fiberNode的子FiberNode。
而要达到这个目的，就有两种方式
- 通过reconcile 流程生成子 FiberNode
- 通过命中 bailout策略，直接复用子 FiberNode

我们要知道，所有的变化，都是由 【自变量】 的改变而造成的。 在React中，自变量包括：
- props
- state
- context

所以是否命中 bailout策略，就是围绕着3个变量展开

在beginwork 流程中，会有两次命中baiout策略的相关判断：

### 第一次判断
> 发生在判断执行update后，立刻就会进行是否能够复用的判断：

1. oldprops === newProps
组件在render之后，拿到的是一个React元素。所以会对两个React元素(前后两次render的结果)进行比较。
如果props属性每一项都没有变化，会被认为是一样的。
注意：
- 每次组件render的时候，会生成一个全新的对象引用，因此 oldProps和newProps 并不会【全等】，此时是没有办法命中bailout策略的。
- 只有当父FiberNode命中bailout策略时，复用子FiberNode，在子FiberNode的beginwork中，oldProps才有可能和newProps全等。


2. Legacy context 没有变化
这个是旧的contextAPI，contextApi重构过一次，之所以重构，就是和bailout策略相关

3. FiberNode.type 没有变化
这里指的是，不能从div->p 这种类型的变化。只能从div->div，p->p 这种类型的变化。

```jsx
// 由于Child 定义在父组件内，所以App每次render时，Child 都是一个新的函数组件，所以Child的FiberNode.type 始终是变化的，是不会命中bailout策略的。
function App(){
    const Child = () => {
        return <div>Child</div>;
    }
    return <Child />;
}

```

4. 当前FiberNode 没有更新发生
当前FiberNode没有发生更新，则意味着state没有发生变化。
```js

function checkScheduledUpdateOrContext(current, renderLanes) {
    // 在执行bailout之前，必须检查是否有待处理的更新或者 context
    const updateLanes = current.lanes;
    if (includesSomeLane(updateLanes, renderLanes)) {
        // 存在更新，返回true
        return true;
    }
    // 不存在更新，返回false
    return false;
}

```
当以上条件都满足的时候，会命中 bailout策略，命中该策略后，会执行 bailoutOnAlreadyFinishedWork方法，在该方法中，会进一步判断优化程序，根据优化程度来决定是整棵子树都命中bailout还是复用子树的 FiberNode

```js
function bailoutOnAlreadyFinishedWork(current ,workInProgress,renderLanes){
     
     if(!includesSomeLane(renderLanes,workInProgress.lanes)){
     
        return null;
     }

// 该FiberNode 没有命中 bailout，但它的子树命中了。 克隆子 FiberNode并继续
     cloneChildFibers(current,workInProgress);
     return workInProgress;
}

```
通过 wipFiberNode.childLanes 就可以快速的排查当前的FiberNode的整颗子树是否存在更新， 如果不存在，直接跳过整颗子树的beginWork。

这其实也是解释了，为什么每次React更新，都会生成一颗完整的FiberTree ，但是性能上并不差的原因。

### 第二次判断

如果第一次没有命中bailout策略，则会根据tag的不同，进入不同的处理逻辑，之后还会再进行第二次的复用判断。

第二次判断的时候会有两种命中的可能：
1. 开发者使用了性能优化的api
在第一次判断的时候，默认对props进行全等比较。要满足这个条件实际上是比较困难的，性能优化api的工作原理主要是改写判断条件。
比如 React.memo， 通过该api创建的FC对应的 FiberNode。tag 为 memoComponent，在beginWork中对应的处理逻辑如下：

```js
const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);
if (!hasScheduledUpdateOrContext) {
    const prevProps = current.memoizedProps;
    
    // 比较函数，默认是进行浅比较
    let compare = Component.compare;
    compare = compare !== null ? compare : shallowEqual;

    if(compare(prevProps,nextProps) && current.ref === workInProgress.ref){
        // 如果 props 经比较未变化，且ref 不变，则命中 bailout 策略
        // 说明组件没有发生变化，直接复用当前 FiberNode
        return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);
    }

}

```
因此，是否命中bailout 策略的条件，就变成了如下三个：
- 不存在更新
- 经过比较厚，props没有变化 （浅比较）
- ref 没有变化

只有同时满足上面三个条件，才会命中bailout策略，执行bailoutOnAlreadyFinishedWork方法，复用当前FiberNode。
相较于第一次的判断，第二次判断props采用浅比较，能够更容易命中bailout策略。

所以，对于ClassComponent的优化手段，经常涉及到的就是 pureComponent 或者 shouldComponentUpdate方法，这两个api 实际上背后也是在优化命中 bailout策略的方式

在ClassComponent的beginWork方法中，就有如下的代码：
```js
if (!shouldUpdate && !didCaptureError) {
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
}
```

shouldUpdate 变量受 checkShouldComponentUpdate 方法的影响 

```js
function checkShouldComponentUpdate(
    workInProgress,
    ctor,
    oldProps,
    newProps,
    oldState,
    newState,
    nextContext
){
    
    // classComponent 实例
    const instance = workInProgress.stateNode;
    if(typeof instance.shouldComponentUpdate === 'function'){
        let shouldUpdate = instance.shouldComponentUpdate(newProps,newState,nextContext);
        // shouldComponentUpdate 执行后的返回值，作为shouldUpdate
        return shouldUpdate;
    }

    if(ctor.prototype && ctor.prototype.isPureReactComponent){
        // 进行浅比较
        return (
        !shallowEqual(oldProps, newProps) ||
        !shallowEqual(oldState, newState)
    )
    }
    return true
}

```
通过上面的代码，可以知道PureComponent通过浅比较来决定shouldUpdate的值，而shouldUpdate的值又决定了是否能够命中bailout策略




2. 虽然有更新，但是state没有变化

在第一次进行判断的时候，其中有一个条件是当前的 fiberNode 没有更新发生。 而没有更新，就意味着state没有改变。
还有一种情况是有更新，但是更新前后计算出来的state 仍然没有变化。


例如在FC 的beginWork中，又下面的逻辑

```ts
function updateFunctionComponent(
    current,
    workInProgress,
    Component,
    nextProps:any,
    renderLanes
){
    if (current !== null && !didReceiveUpdate) {
      // 命中bailout策略
      bailoutHooks(current, workInProgress, renderLanes);
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    // 进入reconcile流程
    reconcileChildren(current, workInProgress, nextProps, renderLanes);
    return workInProgress.child;
}

```

在上面的代码中，是否能够命中 bailout 策略，取决于 didReceiveUpdate。

```js
// updateReducer, 内部在计算新的状态时
if (!is(newState, hook.memoizedState)) {
    markWorkInProgressReceivedUpdate();
}

function markWorkInProgressReceivedUpdate(){
    didReceiveUpdate = true;
}

```






# 总结
1. 在React开发中，性能优化的核心思路是帮助React命中其内部的性能优化策略
2. React内部主要有两大核心优化策略：eagerState和bailout
3. eagerState是一种发生在触发状态更新时的优化策略：在调度更新前就计算新状态，如果状态没有变化，可以完全跳过后续的调度、渲染和提交阶段。
4. bailout是一种发生在render阶段的优化策略：当组件的props和state没有变化时，可以直接复用当前的FiberNode及其子树，跳过reconcile过程
5. 开发者常用的优化API如React.memo、useMemo、useCallback、PureComponent、shouldComponentUpdate等，本质上都是为了帮助React更好地命中bailout策略
6. eagerState和bailout共同构成了React性能优化的基础，前者避免了不必要的更新流程启动，后者避免了不必要的组件渲染和子树遍历

也就是，eagerState决定要不要更新，bailout决定更新中要不要复用。