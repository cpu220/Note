# React事件系统详解

## 概述

在React中，有一套完整的事件系统。如果说React中的FiberTree数据结构是用来描述UI的，那么React的事件系统就是用来描述FiberTree和UI之间的交互的。

对于ReactDOM宿主环境，这套事件系统主要由两部分组成：

### 1. 合成事件对象（SyntheticEvent）
- 合成事件对象是对浏览器原生事件对象的一层封装，兼容主流浏览器
- 拥有和浏览器原生事件相同的API，如`stopPropagation`、`preventDefault`等方法
- 其存在的主要目的是消除不同浏览器在事件对象上的差异

### 2. 模拟事件传播机制
- 利用事件委托原理，基于FiberTree实现了事件的捕获、目标以及冒泡过程
- 提供了一些额外特性：
  - 不同事件对应不同的优先级
  - 定制事件名（如采用统一的onXXX驼峰写法，如onClick）
  - 定制事件行为（如onChange的默认行为与原生的onInput相同）

> 注意：React事件系统需要考虑很多边界问题，因此实际代码量很大

## 事件传播示例

```jsx
const jsx = (
  <div onClick={(e) => console.log("click div")}>
    <h3>你好</h3>
    <button
      onClick={(e) => {
        // e.stopPropagation();
        console.log("click button");
      }}
    >
      点击
    </button>
  </div>
);
```

在默认情况下，点击Button按钮会触发：
1. button对应的onClick事件，打印出**click button**
2. div对应的onClick事件，打印出**click div**

如果取消注释`e.stopPropagation()`，则只会打印出**click button**，说明React的事件机制成功实现了冒泡和阻止冒泡的功能。

## 合成事件对象实现

### SyntheticEvent类

```jsx
/**
 * 合成事件对象类
 */
class SyntheticEvent {
  constructor(e) {
    // 保存原生的事件对象
    this.nativeEvent = e;
  }
  
  // 合成事件对象需要提供一个和原生DOM同名的阻止冒泡的方法
  stopPropagation() {
    // 当开发者调用stopPropagation方法，将该合成事件对象的_stopPropagation设置为true
    this._stopPropagation = true;
    if (this.nativeEvent.stopPropagation) {
      // 调用原生事件对象的stopPropagation方法来阻止冒泡
      this.nativeEvent.stopPropagation();
    }
  }
}
```

这个类实现了：
- 保存原生事件对象的引用
- 提供与原生DOM同名的`stopPropagation`方法
- 在调用时同时设置内部标记和调用原生阻止冒泡方法

## 事件传播机制实现

### 实现步骤

对于可以冒泡的事件，整个事件传播机制的实现步骤如下：

1. 在根元素绑定事件类型对应的事件回调，使用事件委托模式
2. 寻找触发事件的元素，找到对应的FiberNode
3. 收集从当前FiberNode到HostRootFiber之间，所有注册了该事件的回调函数
4. 反向遍历并执行收集的回调函数数组（模拟捕获阶段）
5. 正向遍历并执行收集的回调函数数组（模拟冒泡阶段）

### 事件绑定

```jsx
/**
 * 该方法用于给根元素绑定事件
 * @param {*} container 根元素
 * @param {*} type 事件类型
 */
export const addEvent = (container, type) => {
  container.addEventListener(type, (e) => {
    // 进行事件的派发
    dispatchEvent(e, type);
  });
};

// 使用示例
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(jsx);
addEvent(document.getElementById("root"), "click");
```

### 事件派发

```jsx
const dispatchEvent = (e, type) => {
  // 实例化一个合成事件对象
  const se = new SyntheticEvent(e);
  
  // 拿到触发事件的元素
  const ele = e.target;
  // 对应的fiberNode
  let fiber;

  // 通过DOM元素找到对应的FiberNode
  for (let prop in ele) {
    if (prop.toLocaleLowerCase().includes("fiber")) {
      fiber = ele[prop];
      break;
    }
  }

  // 找到对应的fiberNode之后，开始收集路径上所对应的所有回调函数
  const paths = collectPaths(type, fiber);

  // 模拟捕获阶段 - 从根到目标（反向遍历paths）
  triggerEventFlow(paths, type + 'CAPTURE', se);

  // 模拟冒泡阶段 - 如果没有阻止冒泡，则正向遍历paths数组（从目标节点到根节点）
  if (!se._stopPropagation) {
    // 冒泡阶段 - 从目标到根（正向遍历paths）
    for (let i = 0; i < paths.length; i++) {
      const pathNode = paths[i];
      const callback = pathNode[type];
      if (callback) {
        callback.call(null, se);
      }
      if (se._stopPropagation) {
        break;
      }
    }
  }
};
```

`dispatchEvent`方法实现了完整的事件派发流程，包括：
1. 实例化合成事件对象
2. 查找对应的FiberNode
3. 收集事件回调函数
4. 模拟捕获和冒泡阶段

### 收集事件回调函数

```jsx
/**
 * 收集从目标FiberNode到HostRootFiber路径上的所有事件回调函数
 * @param {string} type 事件类型
 * @param {FiberNode} fiber 触发事件的FiberNode
 * @returns {Array} 收集到的事件回调数组
 */
const collectPaths = (type, fiber) => {
  // 用于存储路径上的所有的回调函数
  const paths = [];
  let currentFiber = fiber;
  
  // 如果不是HostRootFiber，就一直往上遍历
  // 3表示的就是HostRootFiber，也就是整个应用的根节点
  while (currentFiber && currentFiber.tag !== 3) {
    const { memoizedProps, tag } = currentFiber;
    
    // 如果tag对应的值为5，说明是DOM元素对应的FiberNode
    if (tag === 5) {
      const eventName = "bind" + type; // bindCLICK
      
      // 检查当前节点是否有绑定事件
      if (memoizedProps && Object.keys(memoizedProps).includes(eventName)) {
        // 如果当前节点绑定了对应类型的事件，收集到paths数组
        const pathNode = {};
        pathNode[type] = memoizedProps[eventName];
        paths.push(pathNode);
      }
    }
    
    // 继续向上遍历
    currentFiber = currentFiber.return;
  }
  
  return paths;
};
```

`collectPaths`函数的实现思路是：
1. 从目标元素的FiberNode开始，向上遍历到HostRootFiber
2. 收集遍历过程中各节点上绑定的对应事件处理函数
3. 返回收集到的事件回调数组

### paths数组结构

```jsx
[
  {
    click: onClick(e)
  },
  {
    click: onClick(e)
  }
]
```

由于收集过程是从目标元素开始向上遍历的，因此`paths`数组的顺序是：
- [目标元素的回调函数, 父元素的回调函数, 祖父元素的回调函数, ..., 根元素的回调函数]

### 通俗理解事件传播流程

为了更好地理解React事件系统的工作原理，可以将其比喻为：

1. **事件收集**就像是从事故现场（目标元素）往总部（根元素）收集信息，记录沿途所有相关人员（节点）的联系方式（回调函数）

2. 收集完成后，我们有了一个联系方式列表（paths数组），顺序是：事故现场的人→最近的负责人→更高级别的负责人→总部负责人

3. **捕获阶段**就像是总部先了解情况，再逐层通知到现场：我们需要从列表的**末尾**（总部）开始，向前（现场）打电话通知
   - 注意：在这个阶段，只有那些有特殊标记（CAPTURE后缀）的联系人会被通知

4. **冒泡阶段**就像是现场处理完情况后，逐层向上汇报：我们需要从列表的**开头**（现场）开始，向后（总部）打电话汇报

这样设计的好处是，虽然只进行了一次收集（从目标到根），但通过改变遍历方向，就能完整模拟出原生DOM的捕获和冒泡两个阶段，既高效又功能完整。

### 捕获阶段实现

```jsx
/**
 * 触发事件流
 * @param {Array} paths 收集到的事件回调函数数组
 * @param {string} type 事件类型
 * @param {SyntheticEvent} se 合成事件对象
 */
const triggerEventFlow = (paths, type, se) => {
  // 反向遍历paths数组（从根元素回调到目标元素回调）
  for (let i = paths.length - 1; i >= 0; i--) {
    const pathNode = paths[i];
    // 获取对应的回调函数
    const callback = pathNode[type];

    if (callback) {
      callback.call(null, se);
    }
    
    // 如果阻止了冒泡，就不需要继续执行了
    if (se._stopPropagation) {
      break;
    }
  }
};
```

捕获阶段通过从`paths`数组末尾开始反向遍历，实现了从根元素到目标元素的事件传播顺序。

### 冒泡阶段实现

```jsx
if (!se._stopPropagation) {
  // 冒泡阶段 - 从目标到根（正向遍历paths）
  for (let i = 0; i < paths.length; i++) {
    const pathNode = paths[i];
    const callback = pathNode[type];
    if (callback) {
      callback.call(null, se);
    }
    if (se._stopPropagation) {
      break;
    }
  }
}
```

冒泡阶段通过从`paths`数组开头开始正向遍历，实现了从目标元素到根元素的事件传播顺序。

## 总结

React事件系统通过合成事件对象和模拟事件传播机制，提供了跨浏览器兼容的事件处理能力。其核心实现包括：

1. **合成事件对象**：封装浏览器原生事件对象，提供统一API
2. **事件委托**：在根元素绑定事件，提高性能
3. **事件传播模拟**：
   - 捕获阶段：反向遍历回调函数数组
   - 冒泡阶段：正向遍历回调函数数组
4. **冒泡控制**：通过_stopPropagation标记控制事件传播

以上就是React事件合成机制的简化实现，展示了其核心工作原理。

按照顺序来看的：
1. 先从目标对应的fiberNode开始，向上遍历到HostRootFiber
2. 收集遍历过程中各节点上绑定的对应事件处理函数
3. 返回收集到的事件回调数组
4. 模拟捕获事件进行遍历，从根元素回调到目标元素回调。 判断可执行的回调函数并执行
5. 模拟冒泡事件进行遍历，从目标元素回调到根元素回调。 判断可执行的回调函数并执行
6. 如果在捕获或冒泡阶段调用了`stopPropagation`方法，就会阻止后续事件回调的执行
7. 事件回调执行完成后，会将合成事件对象销毁，释放内存
```jsx
function handleClick(e) {
  console.log(e.target); // 正确
  setTimeout(() => {
    console.log(e.target); // 可能为 null，需先 e.persist()
  }, 0);
}
```
8. 下一个事件触发时，会重新创建新的合成事件对象

> 需要注意的是，由于是先收集的事件回调函数，所以当A事件执行，并且A的事件删除了B事件对应的DOM，但由于B事件在收集路径中，所以B事件的回调函数仍然会被执行。