# nextjs 部署

nextjs 由于是nodejs服务环境，所以不能像静态页面一样打包zip上传，部署流程多了一个nodejs服务的部署。


# 方法一: github actions

## 第一步 创建workflow 工作流
创建 yml 文件 ,配置github actions 触发
在github仓库中，点击`Settings` -> `Actions` -> `New workflow`，找到 `Set up a workflow yourself`

将下面的东西贴进去。

``` yml
// .github/workflows/main.yml


name: 构建和部署 # GitHub Actions 工作流名称

on:
  push:
    branches:
      - main # 当推送到main分支时触发工作流

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest # 使用Ubuntu操作系统作为运行环境
    steps:
      - name: 检出代码 # 步骤1：从仓库检出代码
        uses: actions/checkout@v3
        with:
          persist-credentials: false # 不保留凭据

      - name: 步骤1 - 检查目录
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT }}
          script: |
            echo "=== 开始部署步骤1 - 检查目录 ==="
            
            # 项目路径
            PROJECT_DIR="/www/wwwroot/html/home-test"
            
            # 检查并创建目录
            [ ! -d "$PROJECT_DIR" ] && mkdir -p "$PROJECT_DIR"
            echo "项目目录: $PROJECT_DIR"
            
            echo "=== 步骤1 - 已完成 ==="

      - name: 步骤2 - 从远程仓库拉取最新代码
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT }}
          script: |
            echo "=== 开始部署步骤2 - 从远程仓库拉取最新代码 ==="
            
            PROJECT_DIR="/www/wwwroot/html/home-test"
            CURRENT_BRANCH="${{ github.ref_name }}"
            REPO_URL="https://github.com/${{ github.repository }}.git"
            MAX_RETRIES=3
            CLONE_TIMEOUT=60  # 秒
            
            # 清理并准备目录
            echo "清理旧目录并创建新目录..."
            cd "$(dirname "$PROJECT_DIR")"
            rm -rf "$PROJECT_DIR"
            mkdir -p "$PROJECT_DIR"
            echo "项目目录: $PROJECT_DIR"
            
            # 定义带有超时的克隆函数
            clone_with_timeout() {
              local attempt=$1
              echo "[尝试 $attempt/$MAX_RETRIES] 开始克隆代码..."
              
              # 设置超时并执行克隆，使用-q静默模式减少输出
              if timeout $CLONE_TIMEOUT git clone --depth 1 --single-branch --branch "$CURRENT_BRANCH" "$REPO_URL" "$PROJECT_DIR"; then
                return 0
              else
                local exit_code=$?
                if [ $exit_code -eq 124 ]; then
                  echo "✗ 克隆超时！超过 $CLONE_TIMEOUT 秒"
                else
                  echo "✗ 克隆失败，退出代码: $exit_code"
                fi
                return 1
              fi
            }
            
            # 尝试多次克隆
            success=false
            for ((i=1; i<=MAX_RETRIES; i++)); do
              if clone_with_timeout $i; then
                success=true
                break
              fi
              
              if [ $i -lt $MAX_RETRIES ]; then
                wait_time=$((i * 5))  # 指数退避
                echo "将在 $wait_time 秒后重试..."
                sleep $wait_time
              fi
            done
            
            # 检查克隆结果
            if [ "$success" = true ]; then
              echo "✓ 代码克隆成功！"
              
              # 进入目录并检查内容
              cd "$PROJECT_DIR"
              echo "当前工作目录: $(pwd)"
              echo "获取代码后的目录内容:"
              ls -la | head -10  # 只显示前10个文件
              
              # 验证是否找到package.json
              if [ -f "package.json" ]; then
                echo "✓ 成功找到package.json文件"
              else
                echo "✗ 错误：未找到package.json文件！"
                exit 1
              fi
            else
              echo "✗ 错误：所有克隆尝试均失败！"
              exit 1
            fi
            
            echo "=== 步骤2 - 已完成 ==="

      - name: 步骤3 - 安装项目依赖
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT }}
          script: |
            echo "=== 开始部署步骤3 - 安装项目依赖 ==="
            
            PROJECT_DIR="/www/wwwroot/html/home-test"
            cd "$PROJECT_DIR"
            
            echo "检查package.json文件..."
            ls -la
            
            # 确定使用的包管理器
            echo "✓ 使用npm安装依赖"
            
            # 查找package.json位置
            if [ ! -f "package.json" ]; then
              echo "当前目录未找到package.json，正在查找..."
              PKG_PATH=$(find . -name "package.json" -type f 2>/dev/null | head -1)
              
              if [ -z "$PKG_PATH" ]; then
                echo "✗ 错误：无法找到package.json文件！"
                exit 1
              fi
              
              cd "$(dirname "$PKG_PATH")"
              echo "✓ 在 $(pwd) 目录找到package.json"
            fi
            
            # 安装依赖
            echo "开始安装依赖..."
            npm install --verbose
            
            # 验证安装结果
            if [ $? -eq 0 ]; then
              echo "✓ 依赖安装成功"
            else
              echo "✗ 依赖安装失败"
              exit 1
            fi
            
            echo "=== 步骤3 - 已完成 ==="

      - name: 步骤4 - 构建项目
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT }}
          script: |
            echo "=== 开始部署步骤4 - 构建项目 ==="
            
            PROJECT_DIR="/www/wwwroot/html/home-test"
            cd "$PROJECT_DIR"
            
            # 查找并切换到包含package.json的目录
            if [ ! -f "package.json" ]; then
              echo "当前目录未找到package.json，正在查找..."
              PKG_PATH=$(find . -name "package.json" -type f 2>/dev/null | head -1)
              
              if [ -z "$PKG_PATH" ]; then
                echo "✗ 错误：无法找到package.json文件！"
                exit 1
              fi
              
              cd "$(dirname "$PKG_PATH")"
              echo "✓ 在 $(pwd) 目录找到package.json"
            fi
            
            # 执行构建
            echo "开始构建项目..."
            
            # 使用npm构建
            echo "使用npm构建..."
            if npm run build --verbose; then
              echo "✓ npm构建成功"
            else
              echo "✗ 构建失败！"
              exit 1
            fi
            
            echo "=== 步骤4 - 已完成 ==="

      - name: 步骤5 - 使用PM2重启应用
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT }}
          script: |
            echo "=== 开始部署步骤5 - 使用PM2重启应用 ==="
            
            PROJECT_DIR="/www/wwwroot/html/home-test"
            cd "$PROJECT_DIR"
            
            # 检查PM2进程是否存在，不存在则创建
            echo "正在检查PM2进程状态..."
            pm2 list | grep -q "home"
            if [ $? -ne 0 ]; then
              echo "PM2进程'home'不存在，正在创建新进程..."
              pm2 start npm --name "home" -- start
            else
              echo "PM2进程'home'已存在，正在重启..."
              pm2 restart home
            fi
            
            # 显示PM2进程状态
            pm2 status home
            
            echo "=== 步骤5 - 已完成 ==="
            echo "=== 部署过程已成功完成 ==="



```

## 第二步 配置github actions

在github仓库中，点击`Settings` -> `Secrets and variables` -> `Actions`，添加以下secrets：

 - `SERVER_HOST`：服务器IP地址
 - `SERVER_USERNAME`：服务器登录用户名
 - `SERVER_PASSWORD`：服务器登录密码
 - `SERVER_PORT`：服务器SSH端口，默认22

按照官方的说法， Secrets and variables 内的存储是加密的。所以，就算工程是public，也不会泄露查看。除非工程管理权限足够高，才可以查看。
 



注意：
 - 由于github对国内网络的限制，不是禁止访问，而是流量限制。会导致在步骤2，拉取代码这一环节又非常高的概率失败。目前没有任何解决办法，就是重试。
 - 这种方法其实是让github actions 远程登录服务器，来执行后续的部署步骤。所以，服务器需要开放22端口，并且允许root登录。这是有安全风险的。 最好是设置deploy用户，严格限制deploy用户的权限，只允许执行部署相关的命令。


# 方法二，使用Docker

## 根目录创建Dockerfile文件

> 最好用官方的 [Dockerfile](https://github.com/vercel/next.js/blob/canary/examples/with-docker/Dockerfile)

```Dockerfile
# 简单的Next.js Dockerfile - 使用npm作为包管理器

# 构建阶段
FROM node:22-alpine3.20 AS builder

# 设置工作目录
WORKDIR /app

# 复制package.json和package-lock.json
COPY package.json package-lock.json* ./

# 安装依赖
RUN npm ci

# 复制项目文件
COPY . .

# 构建项目
RUN npm run build

# 运行阶段
FROM node:22-alpine3.20 AS runner

# 设置环境变量
ENV NODE_ENV production
# PORT will be set from .env file at runtime

# 创建非root用户
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

# 设置工作目录
WORKDIR /app

# 复制构建产物
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static
# 复制data目录，确保portfolio.json等数据文件被包含
COPY --from=builder --chown=nextjs:nodejs /app/data ./data

# 切换到非root用户
USER nextjs

# 暴露端口
EXPOSE ${PORT:-3001}

# 启动应用
CMD ["node", "server.js"]
 

```

## 创建Docker镜像存储的仓库
阿里云和腾讯云都有，搜 【镜像仓库】

需要注意的是，要选择 个人仓库。 腾讯云只有广州才有，注意地点不要选错

公共的可以被任何人拉镜像，私人的需要登录态才可以


``` sh
docker build -t home-nextjs  .  # 构建 一个名为 home-nextjs 的镜像
docker login --username=用户名 仓库地址 # 创建仓库后可以查看信息，每个人的仓库都不一样，需要替换为自己的
docker tag [imageId] ccr.ccs.tencentyun.com/cc-docker-test/cc-docker-test-name:[tag] #  imageId 从 docker images 中查看 tag 理解为版本号
docker push ccr.ccs.tencentyun.com/cc-docker-test/cc-docker-test-name:[tag] # 推送镜像到仓库

```

## 云服务器上部署
> 以腾讯云服务器为案例

1. Docker-> 仓库-> 添加仓库
用户名和密码就是创建 镜像仓库时的用户名和密码

2. Docker-> 本地镜像-> 从仓库拉取
3. 创建容器-> 添加端口 -> 对外暴露
4. 反向代理，绑定域名

## 后续更新

方法一： 手动更新，可以自己写脚本，通过npm run build 打包后，触发Docker的build 和推送，然后手动去云服务器更新
方法二： 利用github 的 Actions 登录到服务器进行项目拉取、打包、镜像制作、推送、更新。 但问题和部署方法一一样。
方法三：