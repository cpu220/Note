# 垃圾回收机制

## 学习目标
- 理解垃圾回收的基本概念和必要性
- 掌握常见的垃圾回收算法及其工作原理
- 了解内存泄漏的原因及排查方法
- 学习如何编写内存友好的JavaScript代码

## 相关问题
- 什么是内存泄露？如何避免？
- JavaScript中常见的垃圾回收算法有哪些？
- 如何使用开发工具排查内存泄露？
  - Chrome DevTools的使用方法
  - Node.js环境下的内存泄漏排查工具

## 垃圾回收概述

GC（Garbage Collection，垃圾回收）是一种内存自动管理机制，垃圾回收器可以自动识别并回收分配给程序但已不再使用的内存空间。这使程序员无需手动管理内存分配与释放，有效避免了内存泄漏和悬垂指针等问题。

## 内存管理基础

### 内存生命周期
在JavaScript等高级语言中，内存管理通常经历以下三个阶段：

1. **内存分配**：程序创建变量、对象、函数等时，系统自动分配内存
2. **内存使用**：程序访问和操作已分配的内存空间
3. **内存释放**：当内存不再被使用时，垃圾回收器自动回收内存

### JavaScript中的内存分配
- **原始类型**：如数字、字符串、布尔值等分配在栈内存中
- **引用类型**：如对象、数组、函数等分配在堆内存中，变量持有其引用地址
- **闭包**：函数及其引用的变量会形成闭包，即使函数执行完毕，引用的变量也不会立即被回收

### 垃圾回收的必要性
- 防止内存泄漏导致的应用性能下降
- 避免因内存耗尽而导致的程序崩溃
- 减少手动管理内存的复杂性和错误风险

## 什么是内存泄露

> 内存泄露是指程序中已不再需要使用的内存没有被及时释放，导致内存占用持续增加的现象。这些本应被回收的对象变成了常驻内存的对象，随着时间推移会导致应用程序性能下降、响应延迟，严重时甚至导致崩溃。

在JavaScript等高级语言中，内存管理主要由垃圾回收器自动完成。当我们创建变量、对象、函数等时，系统会自动分配内存；当这些资源不再被引用时，理论上应该被垃圾回收器回收。

然而，当代码中存在逻辑错误导致应该被回收的对象仍然被意外引用时，垃圾回收器就无法释放这部分内存，从而造成内存泄露。这不是垃圾回收机制失效，而是我们的代码阻止了它正常工作。


### 常见内存泄漏原因总结

1. **意外的全局变量**：在函数内部未声明直接赋值的变量会成为全局变量，不会被垃圾回收器回收
2. **未清理的事件监听器**：当DOM元素被移除但相关的事件监听器未移除时，监听器及引用的对象将无法被回收
3. **未清除的定时器**：`setInterval`或未正确清除的`setTimeout`会持续引用回调函数及其闭包中的变量
4. **闭包引起的引用**：闭包会维持对外部变量的引用，即使外部函数已执行完毕
5. **不合理的缓存实现**：未设置上限或过期策略的缓存会不断增长，导致内存占用持续增加
6. **循环引用**：虽然现代垃圾回收器能处理大部分循环引用，但在特定情况下仍可能导致内存泄漏
7. **大对象未及时释放**：长时间持有大型数据结构（如大数组、大对象）而不释放

## 内存泄漏的排查方法

### 使用Chrome DevTools

1. **Memory面板**：
   - **Heap快照(Heap Snapshot)**：对比不同时间点的内存快照，分析对象引用关系
   - **Allocation Timeline**：记录内存分配情况，识别内存增长源
   - **Allocation Sampling**：采样内存分配，找出内存消耗大的函数

2. **Performance面板**：
   - 监控内存使用趋势，观察GC频繁触发的情况
   - 分析页面运行过程中的内存增长模式

3. **Memory分析技巧**：
   - 按构造函数名排序，识别大量相似对象
   - 查看对象的保留大小(Retained Size)，找出占用内存大的对象
   - 分析对象的引用链，找出阻止对象被回收的引用

### Node.js环境内存泄漏排查

1. **使用`--inspect`参数**：
   ```bash
   node --inspect app.js
   ```
   然后在Chrome浏览器中打开`chrome://inspect/#devices`进行调试

2. **使用堆转储工具**：
   - **heapdump模块**：生成堆快照
     ```bash
     npm install heapdump
     ```
     在代码中使用：
     ```javascript
     const heapdump = require('heapdump');
     heapdump.writeSnapshot('./heap-' + Date.now() + '.heapsnapshot');
     ```
   - **clinic.js**：Node.js性能分析工具集
     ```bash
     npm install -g clinic
     clinic doctor -- node app.js
     ```

## 如何避免内存泄漏

1. **使用严格模式**：在JavaScript文件开头添加`'use strict'`，避免意外创建全局变量

2. **合理管理事件监听器**：
   - 使用`addEventListener`添加事件，记得使用`removeEventListener`移除
   - 组件卸载时清理所有相关事件监听器
   - 考虑使用事件委托减少事件监听器数量

3. **正确使用定时器**：
   - 不再需要的定时器一定要清除：`clearInterval`和`clearTimeout`
   - 在组件生命周期结束时清除所有定时器

4. **实现内存友好的缓存**：
   - 使用LRU等缓存策略限制缓存大小
   - 为缓存项设置过期时间
   - 提供手动清理缓存的方法

5. **避免过多的闭包**：
   - 减少不必要的变量引用
   - 函数执行完毕后，避免保留对其内部变量的引用

6. **及时释放大型数据结构**：
   - 不再使用的大型对象设置为`null`
   - 清空不再使用的数组：`arr.length = 0`或重新赋值为`[]`

7. **使用WeakMap和WeakSet**：
   - 对于只需临时引用的对象，使用WeakMap和WeakSet
   - 这些集合不会阻止垃圾回收器回收其引用的对象

## 代码示例

### 内存泄漏示例

#### 1. 意外的全局变量
```javascript
// 不好的做法
function createGlobalVar() {
  // 没有使用var/let/const声明，成为全局变量
  unintendedGlobalVar = new Array(1000000).fill('memory leak');
}

// 好的做法
function avoidGlobalVar() {
  // 使用let声明局部变量
  let intendedLocalVar = new Array(1000000).fill('properly scoped');
  return intendedLocalVar;
}
```

#### 2. 未清理的事件监听器
```javascript
// 不好的做法
function addListener() {
  const btn = document.getElementById('myButton');
  btn.addEventListener('click', function handler() {
    console.log('Button clicked');
  });
  // 当btn被移除时，handler及其引用的变量仍被保留
}

// 好的做法
function properlyManageListener() {
  const btn = document.getElementById('myButton');
  const handler = function() {
    console.log('Button clicked');
  };
  
  btn.addEventListener('click', handler);
  
  // 在组件卸载或不再需要时移除监听器
  return function cleanup() {
    btn.removeEventListener('click', handler);
  };
}
```

#### 3. 未清除的定时器
```javascript
// 不好的做法
function startInterval() {
  setInterval(function() {
    console.log('Running interval');
  }, 1000);
  // 没有保存interval ID，无法清除
}

// 好的做法
function properlyManageInterval() {
  const intervalId = setInterval(function() {
    console.log('Running interval');
  }, 1000);
  
  // 在不再需要时清除定时器
  return function cleanup() {
    clearInterval(intervalId);
  };
}
```

### 垃圾回收与内存优化示例

#### 1. 使用WeakMap避免内存泄漏
```javascript
// 创建一个WeakMap存储缓存
const cache = new WeakMap();

function processObject(obj) {
  // 检查缓存中是否已有结果
  if (cache.has(obj)) {
    console.log('从缓存获取结果');
    return cache.get(obj);
  }
  
  // 处理对象并缓存结果
  const result = heavyComputation(obj);
  cache.set(obj, result);
  return result;
}

// 当obj不再被其他地方引用时，WeakMap中的条目会自动被垃圾回收
```

#### 2. 正确释放大型对象
```javascript
function processLargeData() {
  // 创建大型数据结构
  let largeData = generateLargeDataSet();
  
  // 处理数据
  const processedData = processData(largeData);
  
  // 显式释放大型数据，允许垃圾回收器回收
  largeData = null;  // 关键步骤
  
  return processedData;
}
```

#### 3. 使用LRU缓存限制内存使用
```javascript
class LRUCache {
  constructor(maxSize = 100) {
    this.maxSize = maxSize;
    this.cache = new Map();
  }
  
  get(key) {
    const value = this.cache.get(key);
    if (value === undefined) return null;
    
    // 重新设置key，使其移到Map末尾（最近使用）
    this.cache.delete(key);
    this.cache.set(key, value);
    
    return value;
  }
  
  set(key, value) {
    // 如果已存在，先删除
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }
    // 如果达到最大容量，删除最旧的条目（Map的第一个条目）
    else if (this.cache.size >= this.maxSize) {
      this.cache.delete(this.cache.keys().next().value);
    }
    
    // 设置新值
    this.cache.set(key, value);
  }
  
  clear() {
    this.cache.clear();
  }
}




# 常见垃圾回收算法

垃圾回收器使用不同的算法来识别和回收不再使用的内存。以下是几种主要的垃圾回收算法：

## 1. 标记清除算法(Mark-Sweep)
- 这是最基础也是最常用的垃圾回收算法，现代浏览器主要使用此算法的改进版本
- **工作原理**：
  1. **标记阶段**：从根对象（如全局对象）开始，递归标记所有可达对象
  2. **清除阶段**：遍历整个内存区域，回收所有未被标记的对象
- **优点**：实现简单，能有效处理循环引用问题
- **缺点**：清除后会产生内存碎片

## 2. 引用计数算法(Reference Counting)
- **工作原理**：跟踪每个对象被引用的次数，当引用计数归零时立即回收该对象
- **优点**：可立即回收内存，不需要等待垃圾回收周期
- **缺点**：
  - 无法解决循环引用问题（两个对象互相引用但都不再被其他对象引用）
  - 频繁更新引用计数会带来性能开销
- **现状**：现代浏览器已基本不再使用纯引用计数算法

## 3. 分代回收策略(Generational Collection)
- **工作原理**：基于对象生命周期的特性，将内存分为不同区域（代）
  - **新生代(Young Generation)**：存放新创建的对象，垃圾回收频率高
  - **老生代(Old Generation)**：存放长时间存活的对象，垃圾回收频率低
- **优点**：根据不同代对象的特点采用不同的回收策略，提高整体回收效率
- **实现**：如V8引擎的新生代使用Scavenge算法，老生代使用Mark-Compact算法

## 4. 增量标记-清除算法(Incremental Mark-Sweep)
- **工作原理**：将标记阶段拆分为多个小步骤，与应用程序交替执行
- **优点**：减少垃圾回收对应用程序的阻塞时间，提高用户体验
- **实现**：现代浏览器和JavaScript引擎普遍采用此策略



# V8引擎垃圾回收机制详解

现代JavaScript引擎（如V8）采用了多种垃圾回收算法的组合，下面详细介绍V8引擎中的两种主要垃圾回收算法：

## Mark-Compact 算法（Major GC）
- **应用场景**：主要用于老生代内存的回收
- **工作流程**：
  1. **标记阶段(Marking)**：
     - 从根对象开始，递归遍历整个对象图
     - 标记所有从根对象可达的对象
  2. **整理阶段(Compacting)**：
     - 将所有存活的对象向内存空间的一端移动
     - 更新所有对移动后对象的引用指针
  3. **清除阶段(Sweeping)**：
     - 回收整理后边界外的内存空间
- **优点**：
  - 解决了标记-清除算法产生的内存碎片问题
  - 为大对象分配内存更高效
- **缺点**：
  - 整理阶段需要移动对象并更新引用，开销较大

## Scavenge 算法（Minor GC）
- **应用场景**：用于新生代内存的垃圾回收
- **工作原理**：
  - 采用"半空间复制"（Semi-Space）策略，将新生代内存分为两个等大的空间：From-Space（活动空间）和To-Space（空闲空间）
  - **工作流程**：
    1. 新对象总是分配在From-Space中
    2. 垃圾回收时，标记并复制From-Space中的存活对象到To-Space
    3. 清空From-Space
    4. 交换From-Space和To-Space的角色
  - 对象在经过多次垃圾回收后依然存活，会被晋升到老生代
- **优点**：
  - 执行效率高，尤其适合处理大量快速死亡的对象
  - 复制过程中自动整理内存，不会产生碎片
- **缺点**：
  - 需要额外一半的内存空间作为复制目标
  - 不适合处理大对象和长期存活的对象

## 新生代对象晋升机制
- 对象经过两次垃圾回收后仍然存活会被晋升到老生代
- 当To-Space的使用率超过25%时，对象会提前晋升

## 垃圾回收优化策略

1. **三色标记法(Tri-Color Marking)**：
   - 改进的标记算法，将对象分为白、灰、黑三类，减少垃圾回收暂停时间
   - 配合增量标记和并发标记使用，进一步提高性能

2. **并行回收(Parallel GC)**：
   - 利用多个CPU核心同时执行垃圾回收，加快回收速度

3. **并发回收(Concurrent GC)**：
   - 垃圾回收与JavaScript应用程序代码同时执行，减少主线程阻塞

4. **懒性清理(Lazy Sweeping)**：
   - 延迟执行清理阶段，仅在需要分配内存时进行必要的清理工作

## 核心知识点总结

1. **垃圾回收基础**：
   - 垃圾回收是自动识别和回收不再使用的内存空间的机制
   - 核心问题是如何确定哪些内存不再被程序使用
   - JavaScript采用自动垃圾回收，无需手动管理内存

2. **主要算法**：
   - **标记-清除**：最基础的算法，从根开始标记可达对象，然后清除未标记对象
   - **引用计数**：跟踪对象引用次数，引用为零时回收
   - **分代回收**：根据对象生命周期特点采用不同策略
   - **Mark-Compact**：解决内存碎片问题
   - **Scavenge**：高效处理新生代对象

3. **内存泄漏**：
   - 不再需要的内存未被回收的现象
   - 主要原因包括全局变量、未清理的事件监听器、未清除的定时器等
   - 通过开发工具可以有效排查和解决内存泄漏问题

4. **最佳实践**：
   - 使用严格模式避免意外全局变量
   - 合理管理事件监听器和定时器
   - 实现内存友好的缓存机制
   - 适当使用WeakMap和WeakSet
    - 及时释放不再使用的大型对象

## 总结与展望

垃圾回收是JavaScript运行时环境中的关键机制，它通过自动回收不再使用的内存空间，大大减轻了开发者的内存管理负担。然而，理解垃圾回收的工作原理以及如何编写内存友好的代码，对于开发高性能、可靠的Web应用仍然至关重要。

随着Web应用变得越来越复杂，内存管理的重要性也日益凸显。现代JavaScript引擎（如V8）通过不断优化垃圾回收算法，如引入增量标记、并发回收等技术，显著减少了垃圾回收对应用性能的影响。

