# 事件循环

## 理解
浏览器源码叫 message_loop
事件循环，又叫做消息循环,是浏览器渲染主线程的工作方式
在chrome 的源码中，它开启一个不会结束的for循环，每次循环从消息队列中取出一个任务执行，而其他线程只需要在合适的时候，将任务加入到队列末尾即可。

过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。
根据W3C的官方解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列，不同任务队列有不同的优先级，在一次时间循环中，由浏览器自行决定哪一个队列的任务，但浏览器必须有一个微队列，微队列的任务一定具有最高优先级，必须有限调度执行。


---

event loop ， 是计算机编程中常用的一种【异步】变成模型，事件循环通常包括以下几个关键组件：
1. 事件队列（event queue）
    - 用于储存待处理的事件，事件可以是用户操作，网络请求，定时器等，根据类型没，按照一定的规则将事件放入不同的队列中。等待处理
2. 事件循环 (event loop)
    - 不断地检查时间队列是否有待处理的事件，如果有，按照一定的规则（先进先出）从相应队列中取出事件，放入执行栈中执行。
3. 回调函数 (callback)
    - 与事件相关联的处理函数或代码块。当特定类型的事件发生时，事件循环会调用相应的回调函数来处理该事件
4. 非阻塞I/O
    - 事件循环允许异步执行 I/O 操作，这意味着程序不必等待I/O操作完成，而可以继续执行其他任务，当I/O完成时，相应的回调函数将被调用、

注意： 事件循环的优点在于，它可以提高程序的响应性和效率，特别是在处理大量并发任务时，它在许多变成环境中都有广泛的应用。


## 特点 
* 渲染主线程

* 微队列 ， 优先级最高
* 延迟队列 ， 优先级最低
* 交互队列， 优先级中等

* 先执行全局JS
* 再执行事件处理函数
* 再执行计时器的回调函数
 

分析下面代码，然后用浏览器渲染主线程、微队列、延迟队列、交互队列，讲解代码执行的先后顺序，并说明为什么
``` javascript
function delay (time){
    var start = Date.now();
    while(Date.now() - start < time){}
}

setTimeout(function(){
    console.log('setTimeout');
}, 0);

delay(1000);

Promise.resolve().then(function(){
    console.log('Promise');
});

console.log(2);
```


 

## 分析

代码的执行顺序如下：

1. 首先，JavaScript 解释器开始执行代码，进入全局执行上下文。
2. 执行到 `setTimeout` 函数，将其中的回调函数推入延迟队列（setTimeout队列），并设置延迟时间为0。
3. 执行 `delay(1000)` 函数，该函数会在当前线程中阻塞执行1秒钟，直到时间过去才会继续执行。
4. 执行 `console.log(2)`，打印出数字2。
5. 当1秒钟过去后，`delay` 函数返回，执行线程空闲。
6. 浏览器开始处理微队列（microtask queue），它首先处理 Promise 的回调函数，但在这个例子中没有相关的 Promise 执行。
7. 浏览器继续处理延迟队列（setTimeout队列），发现有一个回调函数等待执行，将其推入主线程准备执行。
8. 回到主线程，执行延迟队列中的回调函数，即打印出字符串 "setTimeout"。
9. 执行完延迟队列中的回调函数后，浏览器继续处理微队列（microtask queue），但此时队列为空，执行线程空闲。

因此，代码的执行顺序是：
2 -> 1秒钟的延迟 -> "setTimeout"

在这个例子中，延迟队列（setTimeout队列）中的回调函数是通过 `setTimeout` 函数添加的，即使设置了延迟时间为0，但由于 JavaScript 是单线程执行的，它需要等待当前代码块执行完毕后才能执行队列中的回调函数。因此，虽然 `setTimeout` 的延迟时间为0，但是它的回调函数仍然需要等待其他代码执行完毕才能被执行。

请注意，浏览器的具体行为可能会有所不同，因为浏览器可能会对任务队列的执行进行优化，但以上是一种常见的执行顺序。



``` javascript
function a(){
    console.log(1)
    Promise.resolve().then(function(){
        console.log(2)
    })
}

setTimeout(function(){
    console.log(3)
    Promise.resolve().then(a)
},0)

Promise.resolve().then(function(){
    console.log(4)
})

console.log(5) 
 

```



