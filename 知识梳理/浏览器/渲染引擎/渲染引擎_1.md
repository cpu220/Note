
1998年，苹果公司参与了KDE开源社区的项目，KHTML
2001年，基于KHTML，苹果开发了webkit
2005年，webkit开源
2013年4月，google宣布从webkit复制出一份，并独立运作开发，Blink。 然后双方互相删除了对方的代码。
  * webkit的一些实现，是以mac os系统为基础，所以存在一些限制，造成了Blink进行了重新的设计
  * 为了将DOM树引入JavaScript引擎中

现在Chrome的内核是Blink，Safari的内核是WebKit，微软Edge的内核也是Blink（从2019年开始）。他们之间的关系是：

Blink是从WebKit分支出来的，所以它们有共同的祖先KHTML。Blink和WebKit之间有一些相似之处，但也有很多不同之处，因为它们各自进行了不同的开发和优化。
WebKit和Blink都使用JavaScriptCore和V8作为JavaScript引擎，但它们对这些引擎也做了不同的修改和改进。
WebKit和Blink都支持大部分的Web标准，如HTML5, CSS3, ECMAScript等，但它们也有一些自己的特性和扩展，如WebKit的CSS属性前缀是-webkit-，而Blink的是-chrome-。

Edge原来的内核是EdgeHTML，它是微软自己开发的一个基于Trident的内核1 。Trident是IE系列浏览器的内核，它从IE4开始使用，一直到

# 渲染引擎
## HTML解释器
解释HTML文本的解释器，主要作用是将HTML文本解释成DOM对象树（document object model ，文本对象模型） 

## CSS解释器
联级样式解释器，作用是为DOM中的各个元素对象计算出样式信息，从而为计算机最后网页的布局提供基础设施
* 除了浏览器的默认样式外，其他的样式js都能操作


## 布局（Layout）
在DOM创建之后，webkit需要将其中的元素对象、同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能够表示这所有信息的内部表示模型
* dom树和layout树不一定是一一对应的
* 内容必须在行盒中

## JavaScript引擎
通过修改网页内容，从而修改css信息，JavaScript代码可以通过DOM接口和CSSOM接口来修改网页内容和样式信息，从而改变渲染的结果

> 需要注意的是，google 使用了 Blink 浏览器内核，虽然核心是从webkit来的，但js引擎，是V8
> 而苹果的safari ，其浏览器内核是webkit，对应的 js 引擎是 JavaScriptCore
> 作为微软的 Edge 浏览器，内核是EdgeHTML，它是从IE浏览器的内核 Trident分出来的，所以可以理解为是全新的内核，和webkit没有什么关系，对应的JS引擎是 Chakra，对应的开源项目是 ChakraCore


## 绘图
使用图形库将布局计算后的各个网页的节点绘制成图像结果。

在这些模块之下，也就是基础，就包括网络、存储、音视频和图片解码器等


## 进程
对于浏览器来说，一个tab就是一个进程。每个页面里的渲染、js引擎、http请求都是线程

### 常驻线程
* GUI 渲染线程
* JavaScript 引擎线程
* 定时触发器
* 事件触发器
* 异步http请求



# 渲染主线程 

浏览器渲染主要是两部分
1. 网络
2. 渲染


当浏览器的网络线程， 收到html文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。
在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程

在事件循环的作用下，渲染主线程取出消息队列的渲染人物，开启渲染了后续的渲染流程。

* 整个渲染流程分为多个阶段
  * html字符串-》 像素解析
  * 解析html-》 样式计算-》布局-》分层-》绘制-》分块-》光栅化-》画-》像素信息





# 1. 解析HTML - parse HTML


渲染主线程： 解析html-》 拿到cssom-》解析html-》生成dom
**预解析**线程-》快速浏览  发现有css文件，用网络线程下载css，然后进行文件解析，生成cssom 交给渲染主线程

- 所以，css解析不会阻塞html的解析，因为在不同的线程上

- 与css不同的是，js则是在html解析过程中，若发现有js文件需要加载，则需要等待文件加载完之后，继续解析。 因为，js有可能更改之前的dom结构，这也是js会阻塞 html 解析的原因
  - 所以，这也是为什么script标签放在body后的原因 
  - 其实可以对script 添加：async、defer、perfetch、perlaod

- 这一步，会得到两棵树， DOM树和CSSOM树
  - DOM树： 由HTML解析而来
  - CSSOM树： 由CSS解析而来


# 2. 样式计算 - recalculate Style
- 遍历得到的 **DOM** 树，依次为树中的每个节点计算出它最终的样式， 称之为 **Computer Style**
  
css属性的计算过程: 层叠，继承
  * 预设值会变成绝对值， red-》 rgb(255,0,0)
视觉格式化模型：盒模型，包含块

- 这一步，得到了一颗样式规则树，这棵树上记录了每一个 **DOM** 节点的样式。

# 3. 布局 - Layout
布局阶段，会依次遍历DOM树的每一个节点，计算每个节点的几何信息。例如节点的宽高，相对包含块的位置
大部分时候，DOM树和layout树并非一一对应。
比如display：node 的节点，几乎没有集合信息，因此不会生成到布局树，又比如使用了伪元素选择器，虽然DOM树种不存在这些伪元素节点，但他们拥有几何信息，所以会生成到**布局树**中，还有匿名行盒等，都会导致无法一一对应。

- 这一步，得到了一颗**布局树**


``` html

<div>
<p>a</p>
b
<p>a</p>
</div>  

```

由于w3c 规定，内容必须在 **行盒** 中，所以 b 会被包含在匿名行盒中，这样就会导致布局树中，div节点下有三个子节点，而不是两个子节点。

# 4. 分层 - Layer
堆叠与上下文有关的属性： z-index,opacity， transform 

主线程会使用一套复杂的策略对整个布局树中进行分层。
分层的好处在于，将来某一个层改编后，仅会对该层进行后续处理，从而提升效率
滚动条，堆叠上下文等样式都会对分层结果产生影响。可以通过 **weil-change** 属性手动调控

# 5. 绘制 - paint 

* 主线程会为每个层单独产生绘制**指令集**，用于描述这一层级的内容如何画出来
* 完成绘制后，主线程将每个图层的绘制信息，交给和合成线程，剩下的工作交给合成线程完成
* 歌城简称首先对每个图层进行分块，将其划分为更多的小区域。它会从家线程池中拿取多个线程来完成分块工作。

- 值得注意的是，canvas就是调用浏览器的 paint方法。

 <!--下面合成线程 -->

# 6. 分块 - tiling
完成会之后，主线程将每个图层的绘制信息，交给合成线程，剩余工作将有合成线程完成。
合成线程首先对每个图层进行分块，将其划分为更多的小区域
他会从**线程池**中拿取多个线程来完成分块工作。

# 7. 光栅化
 分块完成后，就进入光栅化阶段

- 合成线程会将块信息，交给GPU进程，以较高的速度完成光栅化。
- GPU进程会开启多个线程来完成光栅化，并且有限处理靠近视觉区域的 **块**
- 光栅化的结果，就是一块块的**位图**

# 8. 画 /  合成与显示 - composite and display

最后一个阶段就是合成与显示了，也就是画
合成线程拿到每个层，每个块的位图后，生成一个个【quad】指引信息。
指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转，缩放等变形。
变形发生在合成线程，与渲染主线程无关，这就是 transform 会提升性能的原因，效率更高的本质原因

合成线程会把quad 提交给GPU进程，GPU进程产生系统调用，提交给GPU硬件，完成最终的屏幕成像。



# 9. 重绘与回流

## 重排/回流
改变元素的几何属性
reflow 的本质就是重新计算 layout 树。
当进行了会影响不拘束的操作后，需要重新计算布局树，就会引发layout。
为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当js代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。

也同样因为如此，当js 获取布局属性时，就可能造成无法获取到最新的布局信息。
浏览器在反复权衡下，最终决定获取属性立即 reflow

## 重绘
改变元素的可见样式
repaint 的本质就是重新根据分层信息，计算了绘制指令。
当改动了可见样式后，就需要重新计算，会引发repaint
由于元素的布局信息也属于可见样式，所以 reflow 一定会引发 repaint

所以，重排的成本 > 重绘的成本

因为repaint 在合成线程，不在渲染主线程上，所以不会卡顿



# 浏览器打开url地址的过程

1. 浏览器补全URL地址，如果地址中有非ASCII字符，则进行编码
2. 浏览器检查本地缓存，如果有匹配的资源，直接使用缓存，否则继续下一步
3. 浏览器进行DNS解析，获取服务器的IP地址，如果本地没有缓存DNS记录，需要向DNS服务器发送请求，进行DNS解析
   
4. 浏览器与服务器建立TCP链接，进行三次握手
5. 浏览器向服务器发送 HTTP 请求，包括请求头和请求体
6. 服务器接收并处理请求，返回响应头和响应体，响应头中包含了缓存策略和状态码等信息
7. 浏览器根据状态码判断响应结果
   - 200： 成功获取资源
   - 304： 资源未修改，可以使用缓存
8. 浏览器根据缓存策略，决定是否缓存资源
   - cache-control
   - ETag
  
9. 浏览器开始解析HTML文档，构建DOM树 （这一步会阻塞渲染）
10. 解析过程中，如果遇到外部链接的css和js，浏览器会启动新的线程下载，并继续解析HTML
  - 如果script 标签有下面的属性，则会阻塞渲染
  - async： 表示一步执行，下载完成后立刻执行js代码
  - defer，表示延迟执行，下载完成后等待HTML解析结束后，执行JS代码
  - 什么属性都没有，表示同步执行，下载完成后，暂停HTML解析，先执行JS代码。有可能JS会操作DOM变更

11. css文件下载完成后，开始解析CSS文件，构建CSSOM树。 （这一步也会阻塞渲染，因为要确认DOM节点的几何信息） 
12. 将DOM树和CSSOM树合并成渲染树（Render Tree）
13. 根据渲染树计算每个节点的布局（Layout），的到每个节点的几何信息（位置和大小） 
15. 根据分层进行绘制（Paint），生成描述绘制信息的绘制指令集（Painting Orders）
16. 分块、光栅化，将位图展示在屏幕上。
17. 继续解析HTML文档，直到结束