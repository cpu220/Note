
1998年，苹果公司参与了KDE开源社区的项目，KHTML
2001年，基于KHTML，苹果开发了webkit
2005年，webkit开源
2013年4月，google宣布从webkit复制出一份，并独立运作开发，Blink。 然后双方互相删除了对方的代码。
  * webkit的一些实现，是以mac os系统为基础，所以存在一些限制，造成了Blink进行了重新的设计
  * 为了将DOM树引入JavaScript引擎中

现在Chrome的内核是Blink，Safari的内核是WebKit，微软Edge的内核也是Blink（从2019年开始）。他们之间的关系是：

Blink是从WebKit分支出来的，所以它们有共同的祖先KHTML。Blink和WebKit之间有一些相似之处，但也有很多不同之处，因为它们各自进行了不同的开发和优化。
WebKit和Blink都使用JavaScriptCore和V8作为JavaScript引擎，但它们对这些引擎也做了不同的修改和改进。
WebKit和Blink都支持大部分的Web标准，如HTML5, CSS3, ECMAScript等，但它们也有一些自己的特性和扩展，如WebKit的CSS属性前缀是-webkit-，而Blink的是-chrome-。

Edge原来的内核是EdgeHTML，它是微软自己开发的一个基于Trident的内核1 。Trident是IE系列浏览器的内核，它从IE4开始使用，一直到

# 渲染引擎
## HTML解释器
解释HTML文本的解释器，主要作用是将HTML文本解释成DOM对象树（document object model ，文本对象模型） 

## CSS解释器
联级样式解释器，作用是为DOM中的各个元素对象计算出样式信息，从而为计算机最后网页的布局提供基础设施
* 除了浏览器的默认样式外，其他的样式js都能操作


## 布局（Layout）
在DOM创建之后，webkit需要将其中的元素对象、同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能够表示这所有信息的内部表示模型
* dom树和layout树不一定是一一对应的
* 内容必须在行盒中

## JavaScript引擎
通过修改网页内容，从而修改css信息，JavaScript代码可以通过DOM接口和CSSOM接口来修改网页内容和样式信息，从而改变渲染的结果

## 绘图
使用图形库将布局计算后的各个网页的节点绘制成图像结果。

在这些模块之下，也就是基础，就包括网络、存储、音视频和图片解码器等


## 进程
对于浏览器来说，一个tab就是一个进程。每个页面里的渲染、js引擎、http请求都是线程

### 常驻线程
* GUI 渲染线程
* JavaScript 引擎线程
* 定时触发器
* 事件触发器
* 异步http请求



渲染主线程 

浏览器渲染主要是两部分
1. 网络
2. 渲染


当浏览器的网络线程， 收到html文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列

在事件循环的作用下，渲染主线程取出消息队列的渲染人物，开启渲染了后续的渲染流程。

* 整个渲染流程分为多个阶段
  * 解析html-》 样式计算-》布局-》分层-》绘制-》分块-》光栅化-》画-》像素信息





# 1. 解析HTML - parse HTML


渲染主线程： 解析html-》 拿到cssom-》解析html-》生成dom
预解析线程-》快速浏览  发现有css文件，用网络线程下载css，然后进行文件解析，生成cssom 交给渲染主线程

所以，css解析不会阻塞html的解析，因为在不同的线程上

与css不同的是，js则是在html解析过程中，若发现有js文件需要加载，则需要等待文件加载完之后，继续解析。 因为，js有可能更改之前的dom结构


# 2. 样式计算 - recalculate Style

css属性的计算过程: 层叠，继承
  * 预设值会变成绝对值， red-》 rgb(255,0,0)
视觉格式化模型：盒模型，包含块

# 3. 布局 - Layout
布局阶段，会依次遍历DOM树的每一个节点，计算每个节点的集合信息。例如节点的宽高，相对包含块的位置
大部分时候，DOM树和layout树并非一一对应。
比如display：node 的节点，几乎没有集合信息，因此不会生成到布局树，又比如使用哦那个了伪元素选择器，虽然DOM树种不存在这些伪元素节点，但他们拥有集合信息，所以会生成到布局树中，还有匿名行盒等，都会导致无法一一对应。

# 4. 分层 - Layer
堆叠与上下文有关的属性： z-index,opacity， transform 

主线程会使用一套复杂的策略对整个布局树中进行分层。
分层的好处在于，将来某一个层改编后，仅会对该层进行后续处理，从而提升效率
滚动条，堆叠上下文等样式都会对分层结果产生影响。可以通过weil-change 属性手动调控

# 5. 绘制 - paint 
 
 * 主线程会为每个层单独产生绘制指令集，用于描述这一层级的内容如何画出来
 * 完成会之后，主线程讲解每个图层的绘制信息，交给和成绩线程，剩下的工作交给歌城线程完成
 * 歌城简称首先对每个图层进行分块，将其划分为更多的小区域。它会从家线程池中拿取多个线程来完成分块工作。

 <!--下面合成线程 -->

# 6. 分块 - tiling
完成会之后，主线程将每个图层的绘制信息，交给合成线程，剩余工作将有合成线程完成。
合成线程首先对每个图层进行分块，将其划分为更多的小区域
他会从线程池中拿取多个线程来完成分块工作。

# 7. 光栅化
 分块完成后，就进入光栅化阶段

 合成线程会将块信息，交给GPU进城，以较高的速度完成光栅化。
 GPU进城会开启多个线程来完成光栅化，并且有限处理靠近视觉区域的快
 光栅化的结果，就是一块块的位图

# 8. 画 /  合成与显示 - composite and display

最后一个阶段就是合成与显示了，也就是画
合成线程拿到每个层，每个块的位图后，生成一个个【quad】指引信息。
指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转，缩放等变形。
变形发生在合成线程，与渲染主线程无关，这就是 transform 会提升性能的原因，效率更高的本质原因

合成线程会把quad 提交给GPU进城，右GPU进城产生系统调用，提交给GPU应借鉴，完成最终的屏幕成像。



# 9. 重绘与回流

## 重排/回流
reflow 的本质就是重新计算 layout 树。
当进行了会影响不拘束的操作后，需要重新计算布局树，就会引发layout。
为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当js代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。

也同样因为如此，当js 获取布局属性时，就可能造成无法获取到最新的布局信息。
浏览器在反复权衡下，最终决定获取属性立即 reflow

## 重绘
repaint 的本质就是重新根据分层信息，计算了绘制指令。
当改动了可见样式后，就需要重新计算，会引发repaint
由于元素的布局信息也属于可见样式，所以 reflow 一定会引发 repaint

所以，重排的成本 > 重绘的成本